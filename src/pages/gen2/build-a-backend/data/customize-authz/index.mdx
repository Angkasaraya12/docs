import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Customize your auth rules',
  description: 'Learn how to customize and combine your authorization rules.',
  route: "/gen2/build-a-backend/data/customize-authz"
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}


Use the `.authorization()` modifier to configure authorization rules for public, sign-in user, per user, and per user group data access. **Authorization rules operate on the deny-by-default principle**. Meaning that if an authorization rule is not specifically configured, it is denied.

```ts
export const schema = a.schema({
  Post: a.model({
    content: a.string()
  }).authorization([
    // Allow anyone auth'd with an API key to read everyone's posts.
    a.allow.public().to(['read']), 
    // Allow signed-in user to create, read, update,
    // and delete their __OWN__ posts.
    a.allow.owner(),
  ])
})
```

In the example above, everyone (`public`) can read every Post but `owner` (authenticated users) can create, read, update, and delete their own posts. Amplify also allows you to restrict the allowed operations, combine multiple authorization rules, and apply fine-grained field-level authorization.


## Available authorization strategies

Use the guide below to select the correct authorization strategy for your use case:

| **Recommended use case** | **Strategy** | **Provider** |
|---|---|---|
| [Public data access where users or devices are anonymous. Anyone with the AppSync API key is granted access.](/gen2/build-a-backend/data/customize-authz/public-data-access) | `public` | `apiKey` |
| [Recommended for production environment's public data access. Public data access where unauthenticated users or devices are granted permissions using AWS IAM controls.](/gen2/build-a-backend/data/customize-authz/public-data-access) | `public` | `iam` |
| [Per user data access. Access is restricted to the "owner" of a record. Leverages `amplify/auth/resource.ts` Cognito user pool by default.](/gen2/build-a-backend/data/customize-authz/per-user-per-owner-data-access) | `owner` | `userPools` / `oidc` |
| [Any signed-in data access. Unlike owner-based access, **any** signed-in user has access.](/gen2/build-a-backend/data/customize-authz/signed-in-user-data-access) | `private` | `userPools` / `oidc` / `iam` |
| [Per user group data access. A specific or dynamically configured group of users have access](/gen2/build-a-backend/data/customize-authz/user-group-based-data-access) | `group` | `userPools` / `oidc` |
{/* | Define your own custom authorization rule within a Lambda function | `custom` | `function` | */}

## Understand how authorization rules are applied

Authorization rules can be applied globally across all data models in a schema, onto specific data models, and onto specific fields.

Amplify will always use the most specific authorization rule that's available. For example, if there's an authorization rule for a field and an authorization rule for the model that the field belongs to, Amplify will evaluate against the field-level authorization rule. Review [Field-level authorization rules](#field-level-authorization-rules) to learn more.

If there are multiple authorization rules present, they'll be logically OR'ed. Review [Configure multiple authorization rules](#configure-multiple-authorization-rules) to learn more.

Finally, there are special "Admin IAM Roles" that allow you to overrule any authorization logic applied on the API determine the API access completely via its IAM policy.  

### Global authorization rule (only for getting started)

To help you get started, you can define an authorization rule on the data schema that'll be applied to all data models that **don't** have a model-level authorization rule. For production environments, we recommend to remove the global authorization rule and apply specific rules for each model, and if necessary, fields instead.

```ts
export const schema = a.schema({
  // Because no model-level authorization rule is present
  // this model will use the global authorization rule.
  Todo: a.model({
    content: a.string()
  }),

  // Will use model-level authorization rule
  Notes: a.model({
    content: a.string()
    // [Model-level authorization rule]
  }).authorization([a.allow.public().to(['read'])])

// [Global authorization rule]
}).authorization([
  a.allow.public()
])
```

The global authorization rule (in this case `a.allow.public()` - allows anyone to create, read, update, and delete) is applied to every data model.

### Model-level authorization rules

Add an authorization rule to a model to apply the authorization rule to all fields of that model. 

```ts
export const schema = a.schema({
  Post: a.model({
    content: a.string(),
    createdBy: a.string()
    // [Model-level authorization rule]
    // All fields (content, createdBy) will be protected by
    // this authorization rule
  }).authorization([
    a.allow.public().to(['read']), 
    a.allow.owner(),
  ])
})
```

### Field-level authorization rules

When an authorization rule is added to a field, it'll strictly define the authorization rules applied on the field. Field-level authorization rules **do not** inherit model-level authorization rules. Meaning, only the specified field-level authorization rule is applied.

```ts
export const schema = a.schema({
  Employee: a.model({
    name: a.string(),
    email: a.string(),
    // [Field-level authorization rule]
    // This auth rule will be used for the "ssn" field
    // All other fields will use the model-level auth rule
    ssn: a.string().authorization([a.allow.owner()]),
  })

  // [Model-level authorization rule]
  .authorization([
    a.allow.private().to(["read"]),
    a.allow.owner()
  ]),
});
```

In the example above:
- Owners are allowed to create, read, update, and delete Employee records they own
- Any signed in user has read access
- Any signed in user can read data with the exception of the `ssn` field. This field only has owner auth applied, the field-level auth rule means that model-level auth rules are not applied

### Configure multiple authorization rules

When combining multiple authorization rules, they are "logically OR"-ed. In the following example:
- Any user (signed in or not, verified by IAM) is allowed to read all posts
- Owners are allowed to create, read, update, and delete their own posts.

```ts
export const schema = a.schema({
  Post: a.model({
    title: a.string(),
    content: a.string()
  }).authorization([
    a.allow.public("iam").to(["read"]),
    a.allow.owner()
  ])
})
```

On the client side, make sure to always authenticate with the corresponding authorization mode.

```ts
import { generateClient } from 'aws-amplify/api'
import type { Schema } from '@/backend/data/resource' // Path to your backend resource definition

const client = generateClient<Schema>()

// Creating a post is restricted to Cognito User Pools
const { data: newPostResult , errors } = await client.models.Post.create({
	query: queries.createPost,
	variables: { input: { title: 'Hello World' } },
	authMode: 'userPool',
});

// Listing posts is available to all users (verified by IAM)
const { data: listPostsResult , errors } = await client.models.Post.list({
	query: queries.listPosts,
	authMode: 'iam',
});
```

<Overview childPageNodes={props.childPageNodes} />

