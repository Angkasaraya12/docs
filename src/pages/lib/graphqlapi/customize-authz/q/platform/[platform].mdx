export const meta = {
  title: `Customize your auth rules`,
  description: `Learn more about how to customize your auth rules.`,
  filterKey: 'platform',
  supportedPlatforms: INTEGRATION_FILTER_OPTIONS
};

import { generateStaticPaths } from '@/utils/generateStaticPaths.tsx';

import { INTEGRATION_FILTER_OPTIONS } from '@/utils/filter-data.ts';

export const getStaticPaths = () => {
  return generateStaticPaths(meta.filterKey, meta.supportedPlatforms);
};

export const getStaticProps = (context) => {
  return {
    props: {
      platform: context.params.platform,
      filterKind: meta.filterKey
    }
  };
};

<InlineFilter filters={["js", "react-native"]}>

You can customize auth rules in your Amplify GraphQL API to control access levels and implement custom business logic. In this guide we will review ways you can further customize auth rules including applying rules to the model, global, and field levels, combining multiple auth rules, using with other auth providers, and granting Lambda functions access to the API. We will also show how you can use the auth rules access control matrix for visualizing your policy design.

<InlineFilter filters={["js"]}>

<Callout>

**Note:** In the *Connect your app code to the API* guide we covered how to, "Configure the default authorization mode." If you are looking to implement the default authorization mode via an API Key, an Amazon Cognito User Pool, AWS IAM, OpenID Connect (OIDC), or Lambda Authorizer, [please review the guide](/lib/graphqlapi/connect/q/platform/js/#configure-the-amplify-library).

</Callout>

Before you begin, you will need:

* An [application connected to the API](/lib/graphqlapi/connect/q/platform/js/)

</InlineFilter>

<InlineFilter filters={["react-native"]}>

<Callout>

**Note:** In the *Connect your app code to the API* guide we covered how to, "Configure the default authorization mode." If you are looking to implement the default authorization mode via an API Key, an Amazon Cognito User Pool, AWS IAM, OpenID Connect (OIDC), or Lambda Authorizer, [please review the guide](/lib/graphqlapi/connect/q/platform/react-native/#configure-the-amplify-library).

</Callout>

Before you begin, you will need:

* An [application connected to the API](/lib/graphqlapi/connect/q/platform/react-native/)

</InlineFilter>

## Understand auth rule levels and auth strategies

Authorization rules operate on the deny-by-default principle which means that if an authorization rule is not specifically configured, it is denied. You can open specific access to your models through auth rules for queries, mutations, and subscriptions. Updating these rules enables you to allow broader access for non-sensitive data while implementing the principle of least privilege for access to sensitive data. Both the level for an auth rule and the different auth strategy will impact this access. 

<Accordion title='How the auth directive works' headingLevel='4' eyebrow='Learn more'>

Definition of the `@auth` directive:
```graphql
# When applied to a type, the directive augments the application with
# owner and group-based authorization rules.
directive @auth(rules: [AuthRule!]!) on OBJECT | FIELD_DEFINITION
input AuthRule {
  allow: AuthStrategy!
  provider: AuthProvider
  ownerField: String # defaults to "owner" when using owner auth
  identityClaim: String # defaults to "sub::username" when using owner auth
  groupClaim: String # defaults to "cognito:groups" when using Group auth
  groups: [String]  # Required when using Static Group auth
  groupsField: String # defaults to "groups" when using Dynamic Group auth
  operations: [ModelOperation] # Required for finer control
}

enum AuthStrategy { owner groups private public custom }
enum AuthProvider { apiKey iam oidc userPools function }
enum ModelOperation {
  create
  update
  delete
  read # Short-hand to allow "get", "list", "sync", "listen", and "search"

  get # Retrieves an individual item
  list # Retrieves a list of items
  sync # Enables ability to sync offline/online changes (including via DataStore)
  listen # Subscribes to real-time changes
  search # Enables ability to search using @searchable directive
}
```

Authorization rules consists of:
- **authorization strategy** (`allow`): who the authorization rule applies to
- **authorization provider** (`provider`): which mechanism is used to apply the authorization rule (API Key, IAM, Amazon Cognito user pool, OIDC)
- **authorized operations** (`operations`): which operations are allowed for the given strategy and provider. If not specified, `create`, `read`, `update`, and `delete` operations are allowed.
  - **`read` operation**: `read` operation can be replaced with `get`, `list`, `sync`, `listen`, and `search` for a more granular query access

<Callout warning>

If you use DataStore instead of the API category to connect to your AppSync API, then you must allow `listen` and `sync` operations for your data model.

</Callout>

**API Keys** are best used for public APIs (or parts of your schema which you wish to be public) or prototyping, and you must specify the expiration time before deploying. **IAM** authorization uses [Signature Version 4](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) to make request with policies attached to Roles. OIDC tokens provided by **Amazon Cognito user pool** or **3rd party OpenID Connect** providers can also be used for authorization, and enabling this provides a simple access control requiring users to authenticate to be granted top level access to API actions.

</Accordion>

### Auth rule levels

Auth rules can be set at the global, model, or field levels. Amplify will always use the most specific authorization rule that's present. For example, a field-level authorization rule will be used in favor of a model-level authorization rule; similarly, a model-level authorization rule will be used in favor of a global authorization rule.

#### Global authorization rule (only for getting started)

To help you get started, there's a global authorization rule defined when you create a new GraphQL schema. For production environments, remove the global authorization rule and apply rules on each model instead.

<BlockSwitcher>

<Block name="Amplify CLI">

```graphql
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } }
```

</Block>
<Block name="AWS CDK">

In the CDK construct, we call this the "sandbox mode" that you need to explicitly enable via an input parameter. 

```ts
new AmplifyGraphqlApi(this, "MyNewApi", {
  ...,
  translationBehavior: {
    sandboxModeEnabled: true
  }
});
```

</Block>

</BlockSwitcher>

The global authorization rule (in this case `{ allow: public }` - allows anyone to create, read, update, and delete) is applied to every data model in the GraphQL schema.

<Callout warning>

Currently, only `{ allow: public }` is supported as a global authorization rule.

</Callout>

#### Model authorization rules

A model authorization rule sets access for an entire model type in your GraphQL schema. In the example below, each signed-in user, or also known as "owner", of a Todo can create, read, update, and delete their own Todos:

```graphql
type Todo @model @auth(rules: [{ allow: owner }]) {
  content: String
}
```

Amplify also allows you to restrict the allowed operations, combine multiple authorization rules, and apply fine-grained field-level authorization. In the example below, everyone (`public`) can read every Todo but authenticate users (`owner`) can create, read, update, and delete their own Todos:

``` graphql
type Todo @model @auth(rules: [
  { allow: public, operations: [read]},
  { allow: owner }
]) {
  content: String
}
```

### Field authorization rules

When an authorization rule is added to a field, it will strictly define the authorization rules applied on the field. Field-level authorization rules **do not** inherit model-level authorization rules. Meaning, only the specified field-level authorization rule is applied.

In the example below you can see that:
- Owners are allowed to create, read, update, and delete Employee records they own
- Any signed in user has read access to the list of employees' `name` and `email` fields
- Only an owner has CRUD access to the `ssn` field as the field-level auth rule means that model-level auth rules are not applied

```graphql
type Employee @model @auth(rules: [
  { allow: private, operations: [read] },
  { allow: owner }
]) {
  name: String
  email: String
  ssn: String @auth(rules: [{ allow: owner }])
}
```

<Callout warning>

To prevent sensitive data from being sent over subscriptions, the GraphQL Transformer needs to alter the response of mutations for those fields by setting them to null. Therefore, to facilitate field-level authorization with subscriptions, you need to either apply field-level authorization rules to all **required** fields, make the other fields nullable, or disable subscriptions by setting it to public or off.

</Callout>

#### Protect data at the field level

The user or role that attempts to `delete` a record should have delete permissions on every field of the `@model` annotated GraphQL type to prevent unintended loss of data. For example, in the schema below the `description` field is not accessible by "Admin" Cognito group users and they cannot delete any `Todo` records: 

```graphql
type Todo @model @auth(rules: [
  { allow: private, provider: iam }, 
  { allow: groups, groups: ["Admin"] }
]) {
 id: ID!
 name: String! @auth(rules: [
   { allow: private, provider: iam }, 
   { allow: groups, groups: ["Admin"] }
 ])
 description: String @auth(rules: [{ allow: private, provider: iam }])
}
```

### Authorization strategies and providers

You can further update your authorization rules by your strategy and the related provider for these options. Use the guide below to select the correct authorization strategy for your use case:

| **Recommended use case** | **Strategy** | **Provider** |
|---|---|---|
| Public data access where users or devices are anonymous. Anyone with the AppSync API key is granted access. | [`public`](#public-data-access) | `apiKey` |
| Recommended for production environment's public data access. Public data access where unauthenticated users or devices are granted permissions using AWS IAM controls. | [`public`](#public-data-access) | `iam` |
| Per user data access. Access is restricted to the "owner" of a record. Leverages `amplify add auth` Cognito user pool by default. | [`owner`](#per-user--owner-based-data-access) | `userPools` / `oidc` |
| Any signed-in data access. Unlike owner-based access, **any** signed-in user has access. | [`private`](#signed-in-user-data-access) | `userPools` / `oidc` / `iam` |
| Per user group data access. A specific or dynamically configured group of users have access | [`groups`](#user-group-based-data-access) | `userPools` / `oidc` |
| Define your own custom authorization rule within a Lambda function | [`custom`](#custom-authorization-rule) | `function` |

#### Public data access

To grant everyone access, use the `public` authorization strategy. Behind the scenes, the API will be protected with an API Key.

```graphql
type Todo @model @auth(rules: [{ allow: public }]) {
  content: String
}
```

You can also override the authorization provider. In the example below, `iam` is specified as the provider which allows you to use an "Unauthenticated Role" from the Cognito identity pool for public access instead of an API Key.

First set up the "Unauthenticated Role":

<BlockSwitcher>
<Block name="Amplify CLI">

When you run `amplify add auth`, the  Amplify CLI generates scoped down IAM policies for the "Unauthenticated role" in Cognito identity pool automatically.

</Block>
<Block name="AWS CDK">

Designate an IAM role for unauthenticated identities by setting the `iamConfig` property:

```ts
// Note: this sample uses the alpha Cognito Identity Pool construct, but is not required, CfnIdentityPool can be used as well
import cognito_identitypool from '@aws-cdk/aws-cognito-identitypool-alpha';

const identityPool = new cognito_identitypool.IdentityPool(stack, 'MyNewIdentityPool', {
  allowUnauthenticatedIdentities: true,
  authenticationProviders: { userPools: [new cognito_identitypool.UserPoolAuthenticationProvider({
    userPool: <your_user_pool>,
    userPoolClient: <your_user_pool_client>,
  })] },
});

new AmplifyGraphqlApi(this, "MyNewApi", {
  definition: AmplifyGraphqlDefinition.fromFiles(path.join(__dirname, "schema.graphql")),
  authorizationModes: {
    defaultAuthorizationMode: 'API_KEY',
    apiKeyConfig: {
      expires: cdk.Duration.days(30)
    },
    iamConfig: {
      identityPoolId: identityPool.identityPoolId,
      authenticatedUserRole: identityPool.authenticatedRole,
      unauthenticatedUserRole: identityPool.unauthenticatedRole,
    }
  },
})
```

</Block>
</BlockSwitcher>

Then you can call this role for public access:

```graphql
# public authorization with provider override
type Post @model @auth(rules: [{ allow: public, provider: iam }]) {
  id: ID!
  title: String!
}
```

#### Per-user or owner-based data access
To restrict a record's access to a specific user, use the `owner` authorization strategy. When `owner` authorization is configured, only the record's `owner` is allowed the specified operations.

```graphql
# The "owner" of a Todo is allowed to create, read, update, and delete their own todos
type Todo @model @auth(rules: [{ allow: owner }]) {
  content: String
}

# The "owner" of a Todo record is only allowed to create, read, and update it.
# The "owner" of a Todo record is denied to delete it.
type Todo @model @auth(rules: [{ allow: owner, operations: [create, read, update] }]) {
  content: String
}
```

Behind the scenes, Amplify will automatically add a `owner: String` field to each record which contains the record owner's identity information upon record creation.

By default, the Cognito user pool's user information is populated into the `owner` field. The value saved includes `sub` and `username` in the format `<sub>::<username>`. The API will authorize against the full value of `<sub>::<username>` or `sub` / `username` separately and return `username`. You can alternatively configure [OpenID Connect as an authorization provider](/cli/graphql/authorization-rules/#using-oidc-authorization-provider).

You can override the `owner` field to your own preferred field, by specifying a custom `ownerField` in the authorization rule.

<Callout>

Do not set `ownerField` to your `@primaryKey` field or `id` field if no primary key is specified. If you want to query by the `ownerField`, use an `@index` on that `ownerField` to create a secondary index.

</Callout>

```graphql
type Todo @model @auth(rules: [{ allow: owner, ownerField: "author" }]) {
  content: String                             #^^^^^^^^^^^^^^^^^^^^
  author: String # record owner information now stored in "author" field
}
```

<Callout warning>

**By default, owners can reassign the owner of their existing record to another user.**

To prevent an owner from reassigning their record to another user, protect the owner field (by default `owner: String`) with a [field-level authorization rule](#field-authorization-rules). For example, in a social media app, you would want to prevent Alice from being able to reassign Alice's Post to Bob.

```graphql
type Todo @model @auth(rules: [{ allow: owner }]) {
   id: ID!
  description: String
  owner: String @auth(rules: [{ allow: owner, operations: [read, delete] }])
}
```

</Callout>

#### Multi-user data access

If you want to grant a set of users access to a record, you can override the `ownerField` to a list of owners. Use this if you want a dynamic set of users to have access to a record.

```graphql
type Todo @model @auth(rules: [{ allow: owner, ownerField: "authors" }]) {
  content: String
  authors: [String]
}
```

In the example above, upon record creation, the `authors` list is populated with the creator of the record. The creator can then update the `authors` field with additional users. Any user listed in the `authors` field can access the record.

#### Signed-in user data access

To restrict a record's access to every signed-in user, use the `private` authorization strategy.

> If you want to restrict a record's access to a specific user, see [Per-user / owner-based data access](#per-user-or-owner-based-data-access). `private` authorization applies the authorization rule to **every** signed-in user access.

```graphql
type Todo @model @auth(rules: [{ allow: private }]) {
  content: String
}
```

In the example above, anyone with a valid JWT token from Cognito user pool are allowed to access all Todos.

You can also override the authorization provider. In the example below, `iam` is specified as the provider which allows you to use an "Authenticated Role" from the Cognito identity pool for public access instead of an API Key.

<BlockSwitcher>
<Block name="Amplify CLI">

When you run `amplify add auth`, the  Amplify CLI generates scoped down IAM policies for the "Authenticated role" in Cognito identity pool automatically.

</Block>
<Block name="AWS CDK">

Designate an IAM role for authenticated identities by setting the `iamConfig` property:

```ts
// Note: this sample uses the alpha Cognito Identity Pool construct, but is not required, CfnIdentityPool can be used as well
import cognito_identitypool from '@aws-cdk/aws-cognito-identitypool-alpha';

const identityPool = new cognito_identitypool.IdentityPool(stack, 'MyNewIdentityPool', {
  allowUnauthenticatedIdentities: true,
  authenticationProviders: { userPools: [new cognito_identitypool.UserPoolAuthenticationProvider({
    userPool: <your_user_pool>,
    userPoolClient: <your_user_pool_client>,
  })] },
});

new AmplifyGraphqlApi(this, "MyNewApi", {
  definition: AmplifyGraphqlDefinition.fromFiles(path.join(__dirname, "schema.graphql")),
  authorizationModes: {
    defaultAuthorizationMode: 'API_KEY',
    apiKeyConfig: {
      expires: cdk.Duration.days(30)
    },
    iamConfig: {
      identityPoolId: identityPool.identityPoolId,
      authenticatedUserRole: identityPool.authenticatedRole,
      unauthenticatedUserRole: identityPool.unauthenticatedRole,
    }
  },
})
```

</Block>
</BlockSwitcher>

```graphql
type Todo @model @auth(rules: [{ allow: private, provider: iam }]) {
  content: String
}
```

You can also use OpenID Connect with `private` authorization. See [OpenID Connect as an authorization provider](/cli/graphql/authorization-rules/#using-oidc-authorization-provider).

<Callout>

**Note:** If you have a connected child model that allows `private` level access, any user authorized to fetch it from the parent model will be able to read the connected child model.

For example,
```graphql
type Todo @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  name: String!
  task: [Task] @hasMany
}

type Task @model @auth(rules: [{ allow: owner }, { allow: private, operations: [read] }]) {
  id: ID!
  description: String!
}
```
In the above relationship, the owner of a `Todo` record can query all the tasks connected to it, since the `Task` model allows `private` read access.

</Callout>

#### User group-based data access

To restrict access based on user groups, use the `group` authorization strategy.

**Static group authorization**: When you want to restrict access to a specific set of user groups, provide the group names in the `groups` parameter. In the example below, only users that are part of the "Admin" user group are granted access to the Salary model:

```graphql
type Salary @model @auth(rules: [{ allow: groups, groups: ["Admin"] }]) {
  id: ID!
  wage: Int
  currency: String
}
```

**Dynamic group authorization**: When you want to restrict access to a set of user groups.

```graphql
# Dynamic group authorization with multiple groups
type Post @model @auth(rules: [{ allow: groups, groupsField: "groups" }]) {
  id: ID!
  title: String
  groups: [String]
}

# Dynamic group authorization with a single group
type Post @model @auth(rules: [{ allow: groups, groupsField: "group" }]) {
  id: ID!
  title: String
  group: String
}
```

With dynamic group authorization, each record contains an attribute specifying what Cognito groups should be able to access it. Use the `groupsField` argument to specify which attribute in the underlying data store holds this group information. To specify that a single group should have access, use a field of type `String`. To specify that multiple groups should have access, use a field of type `[String]`.

By default, `group` authorization leverages Amazon Cognito user pool groups but you can also use OpenID Connect with `group` authorization. See [OpenID Connect as an authorization provider](/cli/graphql/authorization-rules/#using-oidc-authorization-provider).

<Callout>

**Known limitations for real-time subscriptions when using dynamic group authorization**:
1. If you authorize based on a single group per record, then subscriptions are only supported if the user is part of 5 or fewer user groups
2. If you authorize via an array of groups (`groups: [String]` example above),
  - subscriptions are only supported if the user is part of 20 or fewer groups
  - you can only authorize 20 or fewer user groups per record

</Callout>

#### Custom authorization rule

You can define your own custom authorization rule with a Lambda function:

```graphql
type Salary @model @auth(rules: [{ allow: custom }]) {
  id: ID!
  wage: Int
  currency: String
}
```

The Lambda function of choice will receive an authorization token from the client and execute the desired authorization logic. The AppSync GraphQL API will receive a payload from Lambda after invocation to allow or deny the API call accordingly.

<BlockSwitcher>
<Block name="Amplify CLI">

Configure the GraphQL API with the Lambda authorization mode, run the following command in your Terminal:

```bash
amplify update api
```
```
? Select a setting to edit:
> Authorization modes

> Lambda

? Choose a Lambda source:
> Create a new Lambda function
```

</Block>
<Block name="AWS CDK">

To configure a Lambda function as the authorization mode, set the `lambdaConfig` in the CDK construct. Use the `ttl` to designate the toke expiry time.

```ts
const amplifyApi = new AmplifyGraphqlApi(this, "MyNewApi", {
  definition: AmplifyGraphqlDefinition.fromFiles(
    path.join(__dirname, "schema.graphql")
  ),
  authorizationModes: {
    defaultAuthorizationMode: "AWS_LAMBDA",
    lambdaConfig: {
      function: new lambda.Function(this, "MyAuthLambda", {
        code: lambda.Code.fromAsset(path.join(__dirname, "handlers/auth")),
        handler: "index.handler",
        runtime: lambda.Runtime.NODEJS_18_X,
      }),
      ttl: cdk.Duration.seconds(10),
    },
  },
});
```

You can leverage this Lambda function code template as a starting point to author your authorization handler code:

```js
// This is sample code. Please update this to suite your schema

/**
 * @type {import('@types/aws-lambda').APIGatewayProxyHandler}
 */
exports.handler = async (event) => {
  console.log(`EVENT: ${JSON.stringify(event)}`);
  const {
    authorizationToken,
    requestContext: { apiId, accountId },
  } = event;
  const response = {
    isAuthorized: authorizationToken === 'custom-authorized',
    resolverContext: {
      // eslint-disable-next-line spellcheck/spell-checker
      userid: 'user-id',
      info: 'contextual information A',
      more_info: 'contextual information B',
    },
    deniedFields: [
      `arn:aws:appsync:${process.env.AWS_REGION}:${accountId}:apis/${apiId}/types/Event/fields/comments`,
      `Mutation.createEvent`,
    ],
    ttlOverride: 300,
  };
  console.log(`response >`, JSON.stringify(response, null, 2));
  return response;
};
```

</Block>
</BlockSwitcher>

You can use the default Amplify provided template as a starting point for your custom authorization rule. The authorization Lambda function receives:

```json
{
    "authorizationToken": "ExampleAuthToken123123123", # Authorization token specified by client
    "requestContext": {
        "apiId": "aaaaaa123123123example123", # AppSync API ID
        "accountId": "111122223333", # AWS Account ID
        "requestId": "f4081827-1111-4444-5555-5cf4695f339f",
        "queryString": "mutation CreateEvent {...}\n\nquery MyQuery {...}\n", # GraphQL query
        "operationName": "MyQuery", # GraphQL operation name
        "variables": {} # any additional variables supplied to the operation
    }
}
```

Your Lambda authorization function needs to return the following JSON:

```json
{
  // required
  "isAuthorized": true, // if "false" then an UnauthorizedException is raised, access is denied
  "resolverContext": { "banana": "very yellow" }, // JSON object visible as $ctx.identity.resolverContext in VTL resolver templates

  // optional
  "deniedFields": ["TypeName.FieldName"], // Forces the fields to "null" when returned to the client
  "ttlOverride": 10 // The number of seconds that the response should be cached for. Overrides default specified in "amplify update api"
}
```

You can use the Amplify Libraries to set the custom authorization token for [GraphQL API](/lib/graphqlapi/authz#aws-lambda) and [DataStore](/lib/datastore/setup-auth-rules#configure-custom-authorization-logic-with-aws-lambda).




</InlineFilter>
