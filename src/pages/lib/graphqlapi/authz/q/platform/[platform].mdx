export const meta = {
  title: `Configure authorization modes`,
  description: `Learn more about how to configure authorization modes in Amplify's API category`
};

<InlineFilter filters={["android", "ios", "flutter"]}>

For client authorization AppSync supports API Keys, Amazon IAM credentials, Amazon Cognito User Pools, and 3rd party OIDC providers. This is inferred from the `amplifyconfiguration.json`/`.dart` file when you call `Amplify.configure()`. You can configure auth modes for an API using the Amplify CLI or manual configuration.

## Auth Modes

### API key

API Key is the easiest way to setup and prototype your application with AWS AppSync. This means it is also prone to abuse since anyone can easily discover the API Key and make requests to your public service. To have authorization checks, use the other auth modes such as Cognito user pool or AWS IAM. API Key will expiry according to the expiry time set when provisioning AWS AppSync and will require extending it or creating a new one if needed. Default API Key expiry time is 7 days.

### Amazon Cognito User Pools

Amazon Cognito User Pools is most commonly used with AWS AppSync when adding authorization check on your API calls. If your application needs to interact with other AWS services besides AWS AppSync, such as Amazon S3, you will need to use AWS IAM credentials with Amazon Cognito Identity Pools. Amplify CLI can automatically configure this for you and will also automatically use the authenticated user from User Pools to federate with the Identity Pools to provide the AWS IAM credentials in the application. [See this for more information about the differences](https://aws.amazon.com/premiumsupport/knowledge-center/cognito-user-pools-identity-pools/). This allows you to have both User Pools' credentials for AWS AppSync and AWS IAM credentials for other AWS resources. You can learn more about Amplify Auth outlined in the [Accessing credentials section](/lib/auth/access_credentials). 

### IAM

Amazon Cognito Identity Pools allows you to use credentials from AWS IAM in your app. AWS IAM helps you securely control access to AWS resources. You use IAM to control who is authenticated (signed in) and authorized (has permissions) to use AWS resources. [Learn more about IAM](https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html?icmpid=docs_iam_console) . The Amplify CLI can automatically configure this for you.

### OpenID Connect (OIDC)

If you are using a 3rd party OIDC provider you will need to configure it and manage the details of token refreshes yourself. 

### AWS Lambda

You can implement your own custom API authorization logic using an AWS Lambda function. To add a Lambda function as an authorization mode for your AppSync API, go to the **Settings** section of the **AppSync console**.

You will need to manage the details of token refreshes in your application code yourself. 

## Use Amplify CLI to configure authorization modes

Amplify CLI can automatically configure the auth modes for you when running `amplify add api` or `amplify update api` if you want to change the auth mode.

If you already have auth configured, then you need to run `amplify update api` to use this pre-configured auth mode and CLI will not ask for auth settings again.

```bash
amplify update api
```

```console
? Please select from one of the below mentioned services:
    > `GraphQL`
? Select a setting to edit:
    > `Authorization modes`
? Choose the default authorization type for the API
  API key
  Amazon Cognito User Pool
‚ùØ IAM
  OpenID Connect
```

## Manual Configuration

### API Key

Add the following snippet to your `amplifyconfiguration.json`/`.dart` file, under the `awsAPIPlugin`:

```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "API_KEY",
            "apiKey": "[API-KEY]"
        }
    }
}
```

### Amazon Cognito User Pools

Add the following snippet to your `amplifyconfiguration.json`/`.dart` file, under the `awsCognitoAuthPlugin`:

```json
{
    ...
    "awsCognitoAuthPlugin": {
        "CognitoUserPool": {
            "Default": {
                "PoolId": "[POOL-ID]",
                "AppClientId": "[APP-CLIENT-ID]",
                "Region": "[REGION]"
            }
        }
    }
}
```
and under the `awsAPIPlugin`
```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "AMAZON_COGNITO_USER_POOLS",
        }
    }
}

```

<InlineFilter filters={["ios"]}>

Add the following code to your app:

```swift
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        try! Amplify.add(plugin: AWSCognitoAuthPlugin())
        try! Amplify.add(plugin: AWSAPIPlugin())
        try! Amplify.configure()
        print("Amplify initialized")

        return true
    }
```


</InlineFilter>

<InlineFilter filters={["android"]}>

Add the following code to your app:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
Amplify.addPlugin(new AWSApiPlugin());
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
Amplify.addPlugin(AWSApiPlugin())
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

In case you have not added the Cognito libraries to your application, be sure to add them:

```yaml
 environment:
   sdk: ">=2.18.0 <4.0.0"

dependencies:
  flutter:
    sdk: flutter

   amplify_flutter: ^1.0.0
   amplify_api: ^1.0.0
   # Be sure that this is added
   amplify_auth_cognito: ^1.0.0
```

Afterwards add the following code to your app before you configure Amplify:

```dart
await Amplify.addPlugins([
  AmplifyAuthCognito(), 
  AmplifyAPI(modelProvider: ModelProvider.instance),
]);
```

</InlineFilter>

### IAM

Add the following snippet to your `amplifyconfiguration.json`/`.dart` file:

```json
{
    ...
    "awsCognitoAuthPlugin": {
        "CredentialsProvider": {
            "CognitoIdentity": {
                "Default": {
                    "PoolId": "[COGNITO-IDENTITY-POOLID]",
                    "Region": "[REGION]"
                }
            }
        } 
    }
}
```
and under the `awsAPIPlugin`
```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "AWS_IAM",
        }
    }
}
```

### OIDC

Update the `amplifyconfiguration.json`/`.dart` file and code snippet as follows:

```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "OPENID_CONNECT",
        }
    }
}
```

<InlineFilter filters={["ios"]}>


Add the following code to your app:

* Create a subclass of `APIAuthProviderFactory`
```swift
class MyAPIAuthProviderFactory: APIAuthProviderFactory {
    let myAuthProvider = MyOIDCAuthProvider()

    override func oidcAuthProvider() -> AmplifyOIDCAuthProvider? {
        return myAuthProvider
    }
}
```

* Implement your class which conforms to `AmplifyOIDCAuthProvider`:
```swift
class MyOIDCAuthProvider : AmplifyOIDCAuthProvider {
    func getLatestAuthToken() async throws -> String {
       ....
    }
}
```
* Finally, register your instance of `APIAuthProviderFactory` prior to calling `Amplify.configure()`:
```swift
try Amplify.add(plugin: AWSAPIPlugin(apiAuthProviderFactory: MyAPIAuthProviderFactory()))
try Amplify.configure()
```

</InlineFilter>

<InlineFilter filters={["android"]}>

Add the following code to your app:

<BlockSwitcher>
<Block name="Java">

```java
ApiAuthProviders authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider(() -> "[OPEN-ID-CONNECT-TOKEN]")
    .build();
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin">

```kotlin
val authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider { "[OPEN-ID-CONNECT-TOKEN]" }
    .build()
val plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build()
Amplify.addPlugin(plugin)
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

To start, create a provider class inheriting from `OIDCAuthProvider`.

```dart
import 'package:amplify_api/amplify_api.dart';

class CustomOIDCProvider extends OIDCAuthProvider {
  const CustomOIDCProvider();

  @override
  Future<String?> getLatestAuthToken() async => '[OPEN-ID-CONNECT-TOKEN]';
}
```

import warning from "/src/fragments/lib/graphqlapi/flutter/authz/2X_add_plugin.mdx";

<Fragments fragments={{flutter: warning}} />


</InlineFilter>

If you are using Cognito's user pool as the authorization type, this will by default retrieve and use the Access Token for your requests. If you would like to override this behavior and use the ID Token instead, you can treat Cognito user pool as your OIDC provider and use `Amplify.Auth` to retrieve the ID Token for your requests.

<InlineFilter filters={["ios"]}>

```swift

import AWSPluginsCore

class MyOIDCAuthProvider : AmplifyOIDCAuthProvider {
    func getLatestAuthToken() async throws -> String {
        let session = try await Amplify.Auth.fetchAuthSession()
        if let cognitoTokenResult = (session as? AuthCognitoTokensProvider)?.getCognitoTokens() {
            switch cognitoTokenResult {
            case .success(let tokens):
                return tokens.idToken
            case .failure(let error):
                throw error
            }
        }
        
        throw AuthError.unknown("Could not retrieve Cognito token")
    }
}
```

</InlineFilter>

<InlineFilter filters={["android"]}>

Add the following code to your app to initialize API plugin with OIDC auth provider:

<BlockSwitcher>
<Block name="Java">

This implementation uses `CompletableFuture<T>`, which requires `minSdkVersion >= 24`.

```java
ApiAuthProviders authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider(() -> {
        CompletableFuture<String> future = new CompletableFuture<>();
        Amplify.Auth.fetchAuthSession(
            session -> future.complete(((AWSCognitoAuthSession) session)
                .getUserPoolTokens()
                .getValue()
                .getIdToken()),
            future::completeExceptionally
        );
        try {
            return future.get();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    })
    .build();
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin - Callbacks">

This implementation uses `CompletableFuture<T>`, which requires `minSdkVersion >= 24`.

```kotlin
val authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider {
        val future = CompletableFuture<String>()
        Amplify.Auth.fetchAuthSession(
            { future.complete((it as AWSCognitoAuthSession).userPoolTokens.value?.idToken) },
            { future.completeExceptionally(it) }
        )
        future.get()
    }
    .build()
val plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="Kotlin - Coroutines">

This implementation uses `CompletableFuture<T>`, which requires `minSdkVersion >= 24`.

```kotlin
val authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider {
        val session = runBlocking { Amplify.Auth.fetchAuthSession() }
        return (session as AWSCognitoAuthSession).userPoolTokens.value?.idToken
    }
    .build()
val plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="RxJava">

Using the `rxbindings` module can simplify this further.

```groovy
dependencies {
    // other dependencies...
    implementation 'com.amplifyframework:rxbindings:ANDROID_VERSION'
}
```

```java
ApiAuthProviders authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider(() -> RxAmplify.Auth.fetchAuthSession()
        .map(session -> ((AWSCognitoAuthSession) session)
            .getUserPoolTokens()
            .getValue()
            .getIdToken())
        .blockingGet())
    .build();
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin (with RxJava)">

Using the `rxbindings` module can simplify this further.

```groovy
dependencies {
    // other dependencies...
    implementation 'com.amplifyframework:rxbindings:ANDROID_VERSION'
}
```

```kotlin
val authProviders = ApiAuthProviders.builder()
    .oidcAuthProvider { RxAmplify.Auth.fetchAuthSession()
        .map { (it as AWSCognitoAuthSession)
            .userPoolTokens
            .value
            ?.idToken }
        .blockingGet() }
    .build()
val plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build()
Amplify.addPlugin(plugin)
```

</Block>
</BlockSwitcher>


</InlineFilter>


<InlineFilter filters={["flutter"]}>

Change the custom provider to retrieve the current session:

```dart
import 'package:amplify_api/amplify_api.dart';
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';

class CustomOIDCProvider extends OIDCAuthProvider {
  const CustomOIDCProvider();

  @override
  Future<String?> getLatestAuthToken() async {
    final session = await Amplify.Auth.fetchAuthSession() as CognitoAuthSession;
    return session.userPoolTokens?.idToken;
  }
}
```

import warning from "/src/fragments/lib/graphqlapi/flutter/authz/2X_add_plugin.mdx";

<Fragments fragments={{flutter: warning}} />


</InlineFilter>

### AWS Lambda

Amplify CLI does not currently allow you to configure Lambda as an authorization mode for your GraphQL API. To add a Lambda function as an authorization mode for your AppSync API, go to the **Settings** section of the **AppSync console**. Then, update the `authorizationType` value in the `amplifyconfiguration.json`/`.dart` file and code snippet as follows:

```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "AWS_LAMBDA",
        }
    }
}
```

<InlineFilter filters={["ios"]}>


Add the following code to your app:

* Create a subclass of `APIAuthProviderFactory`
```swift
class MyAPIAuthProviderFactory: APIAuthProviderFactory {
    let myAuthProvider = MyFunctionAuthProvider()

    override func functionAuthProvider() -> AmplifyFunctionAuthProvider? {
        return MyFunctionAuthProvider()
    }
}
```

* Implement your class which conforms to `AmplifyFunctionAuthProvider`:
```swift
class MyFunctionAuthProvider : AmplifyFunctionAuthProvider {
    func getLatestAuthToken() async throws -> String {
       ....
    }
}
```
* Finally, register your instance of `APIAuthProviderFactory` prior to calling `Amplify.configure()`:
```swift
try Amplify.add(plugin: AWSAPIPlugin(apiAuthProviderFactory: MyAPIAuthProviderFactory()))
try Amplify.configure()
```

</InlineFilter>


<InlineFilter filters={["android"]}>

Add the following code to your app:

<BlockSwitcher>
<Block name="Java">

```java
ApiAuthProviders authProviders = ApiAuthProviders.builder()
    .functionAuthProvider(() -> "[AWS-LAMBDA-AUTH-TOKEN]")
    .build();
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin">

```kotlin
val authProviders = ApiAuthProviders.builder()
    .functionAuthProvider { "[AWS-LAMBDA-AUTH-TOKEN]" }
    .build()
val plugin = AWSApiPlugin.builder()
    .apiAuthProviders(authProviders)
    .build()
Amplify.addPlugin(plugin)
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

To start, create a provider class inheriting from `FunctionAuthProvider`.

```dart
class CustomFunctionProvider extends FunctionAuthProvider {
    const CustomFunctionProvider();

    @override
    Future<String?> getLatestAuthToken() async => '[AWS-LAMBDA-AUTH-TOKEN]';
}
```

import warning from "/src/fragments/lib/graphqlapi/flutter/authz/2X_add_plugin.mdx";

<Fragments fragments={{flutter: warning}} />


</InlineFilter>

### NONE
You can also set authorization mode to `NONE` so that the library will not provide any request interception logic. You can use this when your API does not require any authorization or when you want to manipulate the request yourself, such as adding header values or authorization data.

```json
{
    ...
    "awsAPIPlugin": {
        "[YOUR-GRAPHQLENDPOINT-NAME]": {
            "endpointType": "GraphQL",
            "endpoint": "[GRAPHQL-ENDPOINT]",
            "region": "[REGION]",
            "authorizationType": "NONE",
        }
    }
}
```

You can register your own request interceptor to intercept the request and perform an action or inject something into your request before it is performed. 

<InlineFilter filters={["ios"]}>

To include custom headers in your outgoing requests, add an `URLRequestInterceptor` to the `AWSAPIPlugin`. Also specify the name of one of the APIs configured in your **amplifyconfiguration.json** file.

```swift
struct CustomInterceptor: URLRequestInterceptor {
    func intercept(_ request: URLRequest) throws -> URLRequest {
        var request = request
        request.setValue("headerValue", forHTTPHeaderField: "headerKey")
        return request
    }
}
let apiPlugin = try AWSAPIPlugin()
try Amplify.addPlugin(apiPlugin)
try Amplify.configure()
try apiPlugin.add(interceptor: CustomInterceptor(), for: "yourApiName")
```


</InlineFilter>

<InlineFilter filters={["android"]}>

To specify your own headers, use the `configureClient()` configuration option on the `AWSApiPlugin`'s builder. Specify the name of one of the configured APIs in your **amplifyconfiguration.json**. Apply customizations to the underlying OkHttp instance by providing a lambda expression as below.

<BlockSwitcher>
<Block name="Java">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName", okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName") { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName") { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="RxJava">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName", okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
RxAmplify.addPlugin(plugin);
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

The simplest option for GraphQL requests is to use the `headers` property of a `GraphQLRequest`.

```dart
Future<void> queryWithCustomHeaders() async {
  final operation = Amplify.API.query<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      headers: {'customHeader': 'someValue'},
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}
```

Another option is to use the `baseHttpClient` property of the API plugin which can customize headers or otherwise alter HTTP functionality for all HTTP calls.

```dart
// First create a custom HTTP client implementation to extend HTTP functionality.
class MyHttpRequestInterceptor extends AWSBaseHttpClient {
  @override
  Future<AWSBaseHttpRequest> transformRequest(
    AWSBaseHttpRequest request,
  ) async {
    request.headers.putIfAbsent('customHeader', () => 'someValue');
    return request;
  }
}

// Then you can pass an instance of this client to `baseHttpClient` when you configure Amplify.
await Amplify.addPlugins([
  AmplifyAPI(baseHttpClient: MyHttpRequestInterceptor()),
]);
```


</InlineFilter>

## Configure multiple authorization modes

<Callout warning>

There is currently [a known issue](https://github.com/aws-amplify/amplify-flutter/issues/1867) where enabling multi-auth modes for the API plugin may break DataStore functionality if the DataStore plugin is also used in the same App.

If you are planning to enable multi-auth for _only_ the DataStore plugin, please refer to the [configure multiple authorization types](/lib/datastore/setup-auth-rules/#configure-multiple-authorization-types) section in DataStore documentation.

If you are planning to enable multi-auth for both the API and DataStore plugins, please monitor the aforementioned issue for the latest progress and updates.

</Callout>

This section talks about the capability of AWS AppSync to configure multiple authorization modes for a single AWS AppSync endpoint and region. Follow the [AWS AppSync Multi-Auth](https://docs.aws.amazon.com/appsync/latest/devguide/security.html#using-additional-authorization-modes) to configure multiple authorization modes for your AWS AppSync endpoint.

You can now configure a single GraphQL API to deliver private and public data. Private data requires authenticated access using authorization mechanisms such as IAM, Cognito User Pools, and OIDC. Public data does not require authenticated access and is delivered through authorization mechanisms such as API Keys. You can also configure a single GraphQL API to deliver private data using more than one authorization type. For example, you can configure your GraphQL API  to authorize some schema fields using OIDC, while other schema fields through Cognito User Pools and/or IAM.

As discussed in the above linked documentation, certain fields may be protected by different authorization types. This can lead the same query, mutation, or subscription to have different responses based on the authorization sent with the request; Therefore, it is recommended to use the different `friendly_name_<AuthMode>` as the `apiName` parameter in the `Amplify.API` call to reference each authorization type.

The following snippets highlight the new values in the `amplifyconfiguration.json`/`.dart` and the client code configurations.

The `friendly_name` illustrated here is created from Amplify CLI prompt. There are 4 clients in this configuration that connect to the same API except that they use different `AuthMode`.

```json
{
    "UserAgent": "aws-amplify-cli/2.0",
    "Version": "1.0",
    "api": {
        "plugins": {
            "awsAPIPlugin": {
                "[FRIENDLY-NAME-API-WITH-API-KEY]": {
                    "endpointType": "GraphQL",
                    "endpoint": "[GRAPHQL-ENDPOINT]",
                    "region": "[REGION]",
                    "authorizationType": "API_KEY",
                    "apiKey": "[API_KEY]"
                },
                "[FRIENDLY-NAME-API-WITH-IAM]": {
                    "endpointType": "GraphQL",
                    "endpoint": "[GRAPHQL-ENDPOINT]",
                    "region": "[REGION]",
                    "authorizationType": "AWS_IAM",
                },
                "[FRIENDLY-NAME-API-WITH-USER-POOLS]": {
                    "endpointType": "GraphQL",
                    "endpoint": "https://xyz.appsync-api.us-west-2.amazonaws.com/graphql",
                    "region": "[REGION]",
                    "authorizationType": "AMAZON_COGNITO_USER_POOLS",
                },
                "[FRIENDLY-NAME-API-WITH-OPENID-CONNECT]": {
                    "endpointType": "GraphQL",
                    "endpoint": "https://xyz.appsync-api.us-west-2.amazonaws.com/graphql",
                    "region": "[REGION]",
                    "authorizationType": "OPENID_CONNECT",
                }
            }
        }
    }
}
```

The `GRAPHQL-ENDPOINT` from AWS AppSync will look similar to `https://xyz.appsync-api.us-west-2.amazonaws.com/graphql`.

<InlineFilter filters={["ios"]}>

When you have configured multiple APIs, you can specify the name of the API as a parameter as the target for an operation:

```swift
let request = GraphQLRequest(apiName: "[FRIENDLY-NAME-API-WITH-API-KEY]", ...)
try await Amplify.API.mutate(request: request)
```

</InlineFilter>

<InlineFilter filters={["android"]}>

When you have configured multiple APIs, you can specify the name of the API as a parameter as the target for an operation:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.mutate(
    "[FRIENDLY-NAME-API-WITH-API-KEY]",
    request,
    response -> Log.i("MyAmplifyApp", "Mutation successful"),
    error -> Log.e("MyAmplifyApp", "Failed to mutate model.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.mutate(
    "[FRIENDLY-NAME-API-WITH-API-KEY]",
    request,
    { Log.i("MyAmplifyApp", "Mutation successful") },
    { Log.e("MyAmplifyApp", "Failed to mutate model.", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val apiName = "[FRIENDLY-NAME-API-WITH-API-KEY]"
    val response = Amplify.API.mutate(request, apiName)
    Log.i("MyAmplifyApp", "Mutation successful")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Failed to mutate model.", error)
}
```

</Block>
</BlockSwitcher>


</InlineFilter>


<InlineFilter filters={["flutter"]}>

When you have multiple authorization modes, you can specify the mode with the `authorizationMode` parameter. You can also specify the API name with the `apiName` parameter.

```dart
Future<void> mutateWithApiKey() async {
  final operation = Amplify.API.mutate<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      authorizationMode: APIAuthorizationType.apiKey,
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}

Future<void> mutateWithIam() async {
  final operation = Amplify.API.mutate<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      authorizationMode: APIAuthorizationType.iam,
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}

Future<void> mutateByApiName() async {
  final operation = Amplify.API.mutate<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      apiName: '[FRIENDLY-NAME-API-WITH-API-KEY]',
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}
```


</InlineFilter>


</InlineFilter>

<InlineFilter filters={["js", "react-native"]}>

## Using Amplify GraphQL client

Each AppSync API is set with a __default__ authorization mode.

AWS AppSync also supports [multiple authorization modes on a single API](https://docs.aws.amazon.com/appsync/latest/devguide/security.html#using-additional-authorization-modes) enabling you to add additional authorization modes.

In order to use this feature with the Amplify GraphQL Client the `API.graphql({...})` function accepts an optional parameter called `authMode`, its value will be one of the supported auth modes:

- `API_KEY`
- `AWS_IAM`
- `OPENID_CONNECT`
- `AMAZON_COGNITO_USER_POOLS`
- `AWS_LAMBDA`

<br />

This is an example of using `AWS_IAM` as an authorization mode:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { API, GraphQLQuery, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as mutations from './graphql/mutations';
import { CreateTodoMutation } from './API';

// Creating a post is restricted to IAM 
const createdTodo = await API.graphql<GraphQLQuery<CreateTodoMutation>>({
  query: mutations.createTodo,
  variables: { input: todoDetails },
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>
<Block name="JavaScript">

```js
import { API, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import * as mutations from './graphql/mutations';

// Creating a post is restricted to IAM 
const createdTodo = await API.graphql({
  query: mutations.createTodo,
  variables: {input: todoDetails},
  authMode: GRAPHQL_AUTH_MODE.AWS_IAM
});
```

</Block>
</BlockSwitcher>

Previous examples uses `graphqlOperation` function. That function only creates an object with two attributes `query` and `variables`. In order to use `authMode` you need to pass this object as is mentioned on the previous example.

<Callout>

When using __AWS_IAM__ for public API access, unauthenticated logins must be enabled. To enable unauthenticated logins, run `amplify update auth` from the command line and choose __Walkthrough all the auth configurations__.

</Callout>

### AWS Lambda

You can implement your own custom API authorization logic using an AWS Lambda function. To add a Lambda as an authorization mode for your AppSync API, go to the **Settings** section of the **AppSync console**.

If you are using a Lambda function as an authorization mode with your AppSync API, you will need to pass an authentication token with each API request and will need to manage token refresh in your application.

The following example assumes `AWS_LAMBDA` is configured as the default authentication type for your API:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...

const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const createdTodo = await API.graphql<GraphQLQuery<CreateTodoMutation>>({
  query: mutations.createTodo,
  variables: {input: todoDetails},
  authToken: lambdaAuthToken
});
```

</Block>
<Block name="JavaScript">

```js
// ...

const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const createdTodo = await API.graphql({
  query: mutations.createTodo,
  variables: {input: todoDetails},
  authToken: lambdaAuthToken
});
```

</Block>
</BlockSwitcher>

If you have a different default authentication type and would like to use `AWS_LAMBDA` with a request:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { GRAPHQL_AUTH_MODE } from '@aws-amplify/api';
import { CreateTodoMutation } from './API';

const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const createdTodo = await API.graphql<GraphQLQuery<CreateTodoMutation>>({
  query: mutations.createTodo,
  variables: {input: todoDetails},
  authMode: GRAPHQL_AUTH_MODE.AWS_LAMBDA,
  authToken: lambdaAuthToken
});
```

</Block>
<Block name="JavaScript">

```js
// ...
import { GRAPHQL_AUTH_MODE } from '@aws-amplify/api';

const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const createdTodo = await API.graphql({
  query: mutations.createTodo,
  variables: {input: todoDetails},
  authMode: GRAPHQL_AUTH_MODE.AWS_LAMBDA,
  authToken: lambdaAuthToken
});
```

</Block>
</BlockSwitcher>

</InlineFilter>