export const meta = {
  title: `Advanced Workflows`,
  description: `Learn more about advanced workflows in Amplify's API category`
};

<InlineFilter filters={["js", "react-native"]}>

## Delta Sync

DeltaSync allows you to perform automatic synchronization with an AWS AppSync GraphQL server. The client will perform reconnection, exponential backoff, and retries when network errors take place for simplified data replication to devices. It does this by taking the results of a GraphQL query and caching it in the local Apollo cache. The DeltaSync API manages writes to the Apollo cache for you, and all rendering in your app (such as from React components, Angular bindings) should be done through a read-only fetch.

In the most basic form, you can use a single query with the API to replicate the state from the backend to the client. This is referred to as a "Base Query" and could be a list operation for a GraphQL type which might correspond to a DynamoDB table. For large tables where the content changes frequently and devices switch between offline and online frequently as well, pulling all changes for every network reconnect can result in poor performance on the client. In these cases you can provide the client API a second query called the "Delta Query" which will be merged into the cache. When you do this the Base Query is run an initial time to hydrate the cache with data, and on each network reconnect the Delta Query is run to just get the changed data. The Base Query is also run on a regular bases as a "catch-up" mechanism. By default this is every 24 hours however you can make it more or less frequent.

By allowing clients to separate the base hydration of the cache using one query and incremental updates in another query, you can move the computation from your client application to the backend. This is substantially more efficient on the clients when regularly switching between online and offline states. This could be implemented in your AWS AppSync backend in different ways such as using a DynamoDB Query on an index along with a conditional expression. You can also leverage Pipeline Resolvers to partition your records to have the delta responses come from a second table acting as a journal. [A full sample with CloudFormation is available in the AppSync documentation](https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-delta-sync.html). The rest of this documentation will focus on the client usage.

You can also use Delta Sync functionality with GraphQL subscriptions, taking advantage of both only sending changes to the clients when they switch network connectivity but also when they are online. In this case you can pass a third query called the "Subscription Query" which is a standard GraphQL subscription statement. When the device is connected, these are processed as normal and the client API simply helps make setting up realtime data easy. However, when the device transitions from offline to online, to account for high velocity writes the client will execute the resubscription along with synchronization and message processing in the following order:

1. Subscribe to any queries defined and store results in an incoming queue
2. Run the appropriate query (If `baseRefreshIntervalInSeconds` has elapsed, run the Base Query otherwise only run the Delta Query)
3. Update the cache with results from the appropriate query
4. Drain the subscription queue and continue processing as normal

Finally, you might have other queries which you wish to represent in your application other than the base cache hydration. For instance a `getItem(id:ID)` or other specific query. If your alternative query corresponds to items which are already in the normalized cache, you can point them at these cache entries with the `cacheUpdates` function which returns an array of queries and their variables. The DeltaSync client will then iterate through the items and populate a query entry for each item on your behalf. If you wish to use additional queries which don't correspond to items in your base query cache, you can always create another instance of the `client.sync()` process.

## Usage

```typescript
// Start DeltaSync
const subscription = client.sync(options)
/*
Under the covers, this is actually an Observable<T> that the AppSync client automatically subscribes to for you, so the returned object is a "subscription". This means that you can automatically stop the synchronization process like so:
*/
// Stop DeltaSync
subscription.unsubscribe();
```

**The `options` object**

**baseQuery**
  - `query`: A `DocumentNode` for the base data (e.g. as returned by [`gql`](https://github.com/apollographql/graphql-tag#gql))
  - `variables` [optional]: An object with the query variables, if any.
  - `baseRefreshIntervalInSeconds` [optional]: Number of seconds after which the base query will be run again. Default value: `86400` (24 hrs)
  - `update` [optional]: A function to update the cache, see: [Apollo's `update` function](https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-mutation-options-update)

**subscriptionQuery**
  - `query`: A `DocumentNode` for the subscription (e.g. as returned by [`gql`](https://github.com/apollographql/graphql-tag#gql))
  - `variables` [optional]: An object with the query variables, if any.
  - `update` [optional]: A function to update the cache, see: [Apollo's `update` function](https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-mutation-options-update)

**deltaQuery**
  - `query`: A `DocumentNode` for the deltas (e.g. as returned by [`gql`](https://github.com/apollographql/graphql-tag#gql))
  - `variables` [optional]: An object with the query variables, if any.
  - `update` [optional]: A function to update the cache, see: [Apollo's `update` function](https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-mutation-options-update)

## The buildSync helper

The quickest way to get started with the DeltaSync feature is by using the `buildSync` helper function. This helper function will build an `options` object with the appropriate `update` functions that will update the cache for you in a similar fashion to the [offline helpers](https://github.com/awslabs/aws-mobile-appsync-sdk-js/blob/master/OFFLINE_HELPERS.md).

The first argument you need to pass is the GraphQL `__typename` for your base query. The second argument is the `options` object from the previous section (without the `update` keys, since those will be generated for you by this helper function).

You can **optionally** pass a `cacheUpdates` parameter to the second argument with the following structure:
- **deltaRecord**: A function which receives a `deltaRecord` (e.g. an individual item in the cache populated by the base/delta/subscription query) and returns an array of GraphQL queries and it's variables to be written to the cache.

Example:

```typescript
  client.sync(
    buildSync("Post", {
      baseQuery: {
        query: DeltaSync.BaseQuery
      },
      subscriptionQuery: {
        query: DeltaSync.Subscription
      },
      deltaQuery: {
        query: DeltaSync.DeltaSync
      },
      cacheUpdates: ( deltaRecord  ) => {
        const id = deltaRecord.id;
        return [{ query: DeltaSync.GetItem, variables: { id: id } }];
      }
    })
  )
```

### Requirements for helper function
- Your `baseQuery` returns a list, not a nested type
- Your `deltaQuery` expects a parameter called `lastSync` of type `AWSTimestamp` and returns a list with the same fields as your `baseQuery` (an optionally, an `aws_ds` field with a value of `'DELETE'` for deletions, any other value for insert/update)
- The mutations that trigger the subscription in your `subscriptionQuery` should return a single record with the same fields as the items from your `baseQuery`, (an optionally, an `aws_ds` field with a value of `'DELETE'` for deletions, any other value for insert/update)

### Example

The schema for this sample is below. [A full sample with CloudFormation is available in the AppSync documentation](https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-delta-sync.html).

```graphql
input CreatePostInput {
	author: String!
	title: String!
	content: String!
	url: String
	ups: Int
	downs: Int
}

enum DeltaAction {
	DELETE
}

type Mutation {
	createPost(input: CreatePostInput!): Post
	updatePost(input: UpdatePostInput!): Post
	deletePost(id: ID!): Post
}

type Post {
	id: ID!
	author: String!
	title: String!
	content: String!
	url: AWSURL
	ups: Int
	downs: Int
	createdDate: String
	aws_ds: DeltaAction
}

type Query {
	getPost(id: ID!): Post
	listPosts: [Post]
	listPostsDelta(lastSync: AWSTimestamp): [Post]
}

type Subscription {
	onDeltaPost: Post
		@aws_subscribe(mutations: ["createPost","updatePost","deletePost"])
}

input UpdatePostInput {
	id: ID!
	author: String
	title: String
	content: String
	url: String
	ups: Int
	downs: Int
}

schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}
```

### Sample queries

```graphql
query Base {
  listPosts {
    id
    title
    author
    content
  }
}

query Delta($lastSync: AWSTimestamp!) {
  listPostsDelta(
    lastSync: $lastSync
  ) {
    id
    title
    author
    content
    aws_ds
  }
}

subscription Subscription {
  onDeltaPost {
    id
    title
    author
    content
    aws_ds
  }
}
```

Define the queries from above in a `./graphql/DeltaSync.js` file to import in your app:

```javascript
import gql from "graphql-tag";

export const BaseQuery = gql`query Base{
  listPosts {
    id
    title
    author
    content
  }
}`;

export const GetItem = gql`query GetItem($id: ID!){
  getPost(id: $id) {
    id
    title
    author
    content
  }
}`;

export const Subscription = gql`subscription Subscription {
  onDeltaPost {
    id
    title
    author
    content
  }
}`;

export const DeltaSync = gql`query Delta($lastSync: AWSTimestamp!) {
  listPostsDelta(
    lastSync: $lastSync
  ) {
    id
    title
    author
    content
    aws_ds
  }
}`;
```

```typescript
import { AWSAppSyncClient, buildSync } from "aws-appsync";
import * as DeltaSync from "./graphql/DeltaSync";

const client = new AWSAppSyncClient({
  // ...
});

const subscription = client.sync(
  buildSync('Post', {
    baseQuery: { query: DeltaSync.BaseQuery },
    subscriptionQuery: { query: DeltaSync.Subscription },
    deltaQuery: { query: DeltaSync.DeltaSync },
    cacheUpdates: ({ id }) => [{ query: DeltaSync.getItem, variables: {id} }]
  })
);

```

### React example

Suppose you have an app created with [Create React App](https://github.com/facebook/create-react-app) with the following structure:

- App.js
  - Sets up `AWSAppSyncClient` and `client.sync` as above
  - Renders `<AllPosts />` and `<SinglePost item={2}>`
- AllPosts.jsx exports `<AllPosts />`
- GetPost.jsx exports `<SinglePost item={id}>`

`App.js`

```typescript
const client = new AWSAppSyncClient({
  url: awsconfig.aws_appsync_graphqlEndpoint,
  region: awsconfig.aws_appsync_region,
  auth: {
    type: awsconfig.aws_appsync_authenticationType,
    apiKey: awsconfig.aws_appsync_apiKey
  }
});

client.hydrated().then(() =>
  client.sync(
    buildSync("Post", {
      baseQuery: {
        query: DeltaSync.BaseQuery
      },
      subscriptionQuery: {
        query: DeltaSync.Subscription
      },
      deltaQuery: {
        query: DeltaSync.DeltaSync
      },
      cacheUpdates: ({ id }) => [
        { query: DeltaSync.GetItem, variables: { id } }
      ]
    })
  )
);

const App = () => (
  <ApolloProvider client={client}>
    <Rehydrated>
      <div>
        <OnePost id="96d5e889-38ba-4846-84d0-a11d6447d34b" />
        <hr />
        <AllPosts />
      </div>
    </Rehydrated>
  </ApolloProvider>
);
```

In `AllPosts.jsx` you would have code like so:

```typescript
const AllPosts = ({ postsList }) => (
  <div>
    <pre style={% raw %}{{ textAlign: "left" }}{% endraw %}>
      {JSON.stringify(postsList, null, 2)}
    </pre>
  </div>
);

export default graphql(DeltaSync.BaseQuery, {
  options: {
    fetchPolicy: "cache-only"
  },
  props: ({ data }) => ({
    postsList: data.listPosts || []
  })
})(AllPosts);
```

In `GetPost.jsx` you would have:

```typescript
const OnePost = ({ post }) => (
  <div>
    <pre style={% raw %}{{ textAlign: "left" }}{% endraw %}>{JSON.stringify(post, null, 2)}</pre>
  </div>
);

export default graphql(DeltaSync.GetItem, {
  options: ({ id }) => ({
    variables: { id },
    fetchPolicy: "cache-only"
  }),
  props: ({ data: { getPost } }) => ({
    post: getPost
  })
})(OnePost);
```

**Note**: The `fetchPolicy` is `cache-only` as all of the network requests are handled automatically by the `client.sync()` operation. You should use this if using different queries in other components as the `client.sync()` API manages the cache lifecycle. If you use another `fetch-policy` such as `cache-and-network` then extra network requests may take place negating the Delta Sync benefits.

## Writing update functions

If you do not want to use the `buildSync` helper then you are responsible for managing cache updates in your application code. Note that this can be a complex process as you will need to manage create, update, and deletes appropriately. An example of this would be updating the cache with a delta record as below, noting that you must update the returned type to match the type from your base query.

```javascript
client.sync({
      baseQuery: { query: DeltaSyncQueries.BaseQuery },
      deltaQuery: {
        query: DeltaSyncQueries.DeltaSync,
        update: (cache, { data: { listPostsDelta } }) => {
          const query = DeltaSyncQueries.GetItem;

          listPostsDelta.forEach(deltaRecord => {
            const variables = { id: deltaRecord.id };

            cache.writeQuery({
              query,
              variables,
              data: { getPost: { ...deltaRecord, __typename: 'Post' } }
            });
          });
        }
      }
    });
```

</InlineFilter>

<InlineFilter filters={["android", "ios", "flutter"]}>

This section describes different use cases for constructing your own custom GraphQL requests and how to approach it. You may want to construct your own GraphQL request if you want to
- retrieve only a subset of the data to reduce data transfer
- retrieve nested objects at a depth that you choose
- combine multiple operations into a single request
- send custom headers to your AppSync endpoint

A GraphQL request is automatically generated for you when using AWSAPIPlugin with the existing workflow. For example, if you have a Todo model, a mutation request to save the Todo will look like this:

<InlineFilter filters={["ios"]}>

```swift
let todo = Todo(name: "my first todo", description: "todo description")
try await Amplify.API.mutate(request: .create(todo))
```

</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Todo todo = Todo.builder()
    .name("My first todo")
    .description("todo description")
    .build();

Amplify.API.mutate(ModelMutation.create(todo),
    result -> Log.i("ApiDemo", "Mutation succeeded."),
    failure -> Log.e("ApiDemo", "Mutation failed.", failure)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val todo = Todo.builder()
    .name("My first todo")
    .description("todo description")
    .build()

Amplify.API.mutate(ModelMutation.create(todo),
    { Log.i("ApiDemo", "Mutation succeeded") },
    { Log.e("ApiDemo", "Mutation failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val todo = Todo.builder()
    .name("My first todo")
    .description("todo description")
    .build()

try {
    val result = Amplify.API.mutate(ModelMutation.create(todo))
    Log.i("ApiDemo", "Mutation succeeded") 
} catch (error: ApiException) {
    Log.e("ApiDemo", "Mutation failed", error) 
}
```

</Block>
<Block name="RxJava">

```java
Todo todo = Todo.builder()
    .name("My first todo")
    .description("todo description")
    .build();

Amplify.API.mutate(ModelMutation.create(todo))
    .subscribe(
        result -> Log.i("ApiDemo", "Mutation succeeded"),
        failure -> Log.e("ApiDemo", "Mutation failed", failure)
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
Future<void> createAndMutateTodo() async {
  final todo = Todo(name: 'my first todo', description: 'todo description');
  final request = ModelMutations.create(todo);
  final response = await Amplify.API.mutate(request: request).response;
  safePrint('Response: $response');
}
```

</InlineFilter>

Underneath the covers, a request is generated with a GraphQL document and variables and sent to the AppSync service. 

```
{ 
  "query": "mutation createTodo($input: CreateTodoInput!) {
    createTodo(input: $input) {
      id
      name
      description
    }
  }",
  "variables": "{
    "input": {
      "id": "[UNIQUE-ID]",
      "name": "my first todo",
      "description": "todo description"
    }
  }
}
```

The different parts of the document are described as follows
- `mutation` - the operation type to be performed, other operation types are `query` and `subscription`
- `createTodo($input: CreateTodoInput!)` - the name and input of the operation. 
- `$input: CreateTodoInput!` - the input of type `CreateTodoInput!` referencing the variables containing JSON input
- `createTodo(input: $input)` - the mutation operation which takes a variable input from `$input`
- the selection set containing `id`, `name`, and `description` are fields specified to be returned in the response

You can learn more about the structure of a request from [GraphQL Query Language](https://graphql.org/learn/) and [AppSync documentation](https://docs.aws.amazon.com/appsync/latest/devguide/graphql-overview.html). To test out constructing your own requests, open the AppSync console using `amplify console api` and navigate to the Queries tab.

## Subset of data

The selection set of the document specifies which fields are returned in the response. For example, if you are displaying a view of the Todo without the description, you can construct the document to omit the field. You can learn more about selection sets [here](https://spec.graphql.org/draft/#sec-Selection-Sets).

```
query getTodo($id: ID!) {
  getTodo(id: $id) {
    id
    name
  }
}
```

The response data will look like this

```json
{
  "data": {
    "getTodo": {
      "id": "111",
      "name": "my first todo"
    }
  }
}
```
First, create your own `GraphQLRequest`

<InlineFilter filters={["ios"]}>

```swift
extension GraphQLRequest {
    static func getWithoutDescription(byId id: String) -> GraphQLRequest<Todo> {
        let operationName = "getTodo"
        let document = """
        query getTodo($id: ID!) {
          \(operationName)(id: $id) {
            id
            name
          }
        }
        """
        return GraphQLRequest<Todo>(
            document: document,
            variables: ["id": id],
            responseType: Todo.self,
            decodePath: operationName
        )
    }
}
```
The decode path specifies which part of the response to deserialize to the `responseType`. You'll need to specify the operation name to deserialize the object at "data.getTodo" successfully into a Todo model.

Then, query for the Todo by a todo id
```swift
try await Amplify.API.query(request: .getWithoutDescription(byId: "[UNIQUE_ID]"))
  // handle result
```

</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
private GraphQLRequest<Todo> getTodoRequest(String id) {
    String document = "query getTodo($id: ID!) { "
        + "getTodo(id: $id) { "
            + "id "
            + "name "
        + "}"
    + "}";
    return new SimpleGraphQLRequest<>(
            document,
            Collections.singletonMap("id", id),
            Todo.class,
            new GsonVariablesSerializer());
}
```

</Block>
<Block name="Kotlin">

```kotlin
private fun getTodoRequest(id: String): GraphQLRequest<Todo> {
    val document = ("query getTodo(\$id: ID!) { "
          + "getTodo(id: \$id) { "
              + "id "
              + "name "
            + "}"
          + "}")
    return SimpleGraphQLRequest(
            document,
            mapOf("id" to id),
            Todo::class.java,
            GsonVariablesSerializer())
}
```

</Block>
</BlockSwitcher>

Then, query for the Todo by a todo id

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(getTodoRequest("[TODO_ID]"),
    response -> Log.d("MyAmplifyApp", "response" + response),
    error -> Log.e("MyAmplifyApp", "error" + error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(getTodoRequest("[TODO_ID]"),
    { Log.d("MyAmplifyApp", "Response = $it") },
    { Log.e("MyAmplifyApp", "Error!", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val response = Amplify.API.query(getTodoRequest("[TODO_ID]"))
    Log.d("MyAmplifyApp", "Query response = $response")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Query failed", error)
}
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
const getTodo = 'getTodo';
const graphQLDocument = '''query GetTodo(\$id: ID!) {
  $getTodo(id: \$id) {
    id
    name
  }
}''';
final getTodoRequest = GraphQLRequest<Todo>(
  document: graphQLDocument,
  modelType: Todo.classType,
  variables: <String, String>{'id': someTodoId},
  decodePath: getTodo,
);
```
The `decodePath` specifies which part of the response to deserialize to the `modelType`. You'll need to specify the operation name (as `decodePath`) and `modelType` to deserialize the object at "data.getTodo" successfully into a `Todo` model.

Then, query for the Todo by a todo id:
```dart
Future<void> queryTodo(GraphQLRequest<Todo> getTodoRequest) async {
  final response = await Amplify.API.query(request: getTodoRequest).response;
  safePrint('Response: $response');
}
```


</InlineFilter>

## Nested Data
If you have a relational model, you can retrieve the nested object by creating a `GraphQLRequest` with a selection set containing the nested object's fields. For example, in this schema, the Post can contain multiple comments and notes.

```graphql
enum PostStatus {
  ACTIVE
  INACTIVE
}

type Post @model {
  id: ID!
  title: String!
  rating: Int!
  status: PostStatus!
  comments: [Comment] @hasMany(indexName: "byPost", fields: ["id"])
  notes: [Note] @hasMany(indexName: "byNote", fields: ["id"])
}

type Comment @model {
  id: ID!
  postID: ID! @index(name: "byPost", sortKeyFields: ["content"])
  post: Post! @belongsTo(fields: ["postID"])
  content: String!
}

type Note @model {
  id: ID!
  postID: ID! @index(name: "byNote", sortKeyFields: ["content"])
  post: Post! @belongsTo(fields: ["postID"])
  content: String!
}
```

If you only want to retrieve the comments, without the notes, create a `GraphQLRequest` for the Post with nested fields only containing the comment fields.

<InlineFilter filters={["ios"]}>

```swift
extension GraphQLRequest {
    static func getPostWithComments(byId id: String) -> GraphQLRequest<Post> {
        let document = """
        query getPost($id: ID!) {
          getPost(id: $id) {
            id
            title
            rating
            status
            comments {
              items {
                id
                postID
                content
              }
            }
          }
        }
        """
        return GraphQLRequest<Post>(
            document: document,
            variables: ["id": id],
            responseType: Post.self,
            decodePath: "getPost"
        )
    }
}

```
Query with `try await Amplify.API.query(request: .getPostWithComments(byId: "[POST_ID]"))`.


</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
private GraphQLRequest<Post> getPostWithCommentsRequest(String id) {
    String document = "query getPost($id: ID!) { "
        + "getPost(id: $id) { "
            + "id "
            + "title "
            + "rating "
            + "status "
            + "comments { "
                + "items { "
                    + "id "
                    + "postID "
                    + "content "
                + "} "
            + "} "
        + "} "
    + "}";
    return new SimpleGraphQLRequest<>(
            document,
            Collections.singletonMap("id", id),
            Post.class,
            new GsonVariablesSerializer());
}
```

</Block>
<Block name="Kotlin">

```kotlin
private fun getPostWithCommentsRequest(id: String): GraphQLRequest<Post> {
    val document = ("query getPost(\$id: ID!) { "
        + "getPost(id: \$id) { "
            + "id "
            + "title "
            + "rating "
            + "status "
            + "comments { "
                + "items { "
                    + "id "
                    + "postID "
                    + "content "
                + "} "
            + "} "
        + "} "
    + "}")
    return SimpleGraphQLRequest(
            document,
            mapOf("id" to id),
            Post::class.java,
            GsonVariablesSerializer())
}
```

</Block>
</BlockSwitcher>

Then query for the Post:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(getPostWithCommentsRequest("[POST_ID]"),
    response -> Log.d("MyAmplifyApp", "response" + response),
    error -> Log.e("MyAmplifyApp", "error" + error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(getPostWithCommentsRequest("[POST_ID]"),
    { Log.d("MyAmplifyApp", "Response = $it") },
    { Log.e("MyAmplifyApp", "Error!", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val response = Amplify.API.query(getPostWithCommentsRequest("[POST_ID]"))
    Log.d("MyAmplifyApp", "Query response = $response")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Query error", error)
}
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
const getPost = 'getPost';
const graphQLDocument = '''query GetPost(\$id: ID!) {
  $getPost(id: \$id) {
    id
    title
    rating
    status
    comments {
      items {
        id
        postID
        content
      }
    }
  }
}''';
final getPostRequest = GraphQLRequest<Post>(
  document: graphQLDocument,
  modelType: Post.classType,
  variables: <String, String>{'id': somePostId},
  decodePath: getPost,
);
```

Then, query for the `Post` with nested comments included in decoded response:
```dart
Future<void> queryPostWithNestedComments(
  GraphQLRequest<Post> getPostRequest,
) async {
  final response = await Amplify.API.query(request: getPostRequest).response;
  safePrint('Response $response');
}
```

</InlineFilter>

## Combining multiple GraphQL operations in a single request

GraphQL allows you to run multiple GraphQL operations (queries/mutations) as part of a single network request from the client code. To perform multiple operations in a single request, you can place them within the same GraphQL document. For example, to retrieve a Post and a Todo:

<InlineFilter filters={["ios"]}>

```swift
extension GraphQLRequest {
    static func get(byPostId postId: String, todoId: String) -> GraphQLRequest<JSONValue> {
        let document = """
        query get($postId: ID!, $todoId: ID!) {
          getPost(id: $postId) {
            id
            title
            rating
          }
          getTodo(id: $todoId) {
            id
            name
          }
        }
        """

        return GraphQLRequest<JSONValue>(
            document: document,
            variables: [
                "postId": postId,
                "todoId": todoId
            ],
            responseType: JSONValue.self
        )
    }
}
```
Notice here that `JSONValue` is used as the `responseType`. `JSONValue` is utility type that can be used to represent an arbitrary JSON response.

Once you have the response data in a `JSONValue`, you can access each object in the JSON structure by encoding it back to Data and decoding it to the expected Model.

```swift
do {
    let response = try await Amplify.API.query(request: .get(byPostId: "[POST_ID]", todoId: "[TODO_ID]"))
    switch response {
    case .success(let data):
        if let todoJSON = data.value(at: "getTodo"),
            let todoData = try? JSONEncoder().encode(todoJSON),
            let todo = try? JSONDecoder().decode(Todo.self, from: todoData) {
            print(todo)
        }
        if let postJSON = data.value(at: "getPost"),
            let postData = try? JSONEncoder().encode(postJSON),
            let post = try? JSONDecoder().decode(Post.self, from: postData) {
            print(post)
        }
    case .failure(let errorResponse):
        print("Response contained errors: \(errorResponse)")
    }
} catch let error as APIError {
    print("Failed with error: \(error)")
} catch {
    print("Unexpected error: \(error)")
}
```

If you have custom models or your Model has required fields that you have decided not to include in the response, you can create a `Codable` that conforms to the structure of the response data that you expect. From the previous example, the `Codable` would look like this

```swift
struct PostAndTodoResponse: Codable {
    public let getTodo: Todo
    public let getPost: Post
    struct Todo: Codable {
        public let id: String
        public var name: String
    }
    struct Post: Codable {
        public let id: String
        public var title: String
        public var rating: Int
    }
}
```
Then use `PostAndTodoResponse` as the `responseType` of the `GraphQLRequest` instead of using `JSONValue`.


</InlineFilter>

<InlineFilter filters={["android"]}>


<BlockSwitcher>
<Block name="Java">

```java
private GraphQLRequest<String> getPostAndTodo(String postId, String todoId) {
    String document = "query get($postId: ID!, $todoId: ID!) { "
        + "getPost(id: $postId) { "
            + "id "
            + "title "
            + "rating "
        + "} "
        + "getTodo(id: $todoId) { "
            + "id "
            + "name "
        + "} "
    + "}";
    Map<String, Object> variables = new HashMap<>();
    variables.put("postId", postId);
    variables.put("todoId", todoId);
    return new SimpleGraphQLRequest<>(
            document,
            variables,
            String.class,
            new GsonVariablesSerializer());
}
```

</Block>
<Block name="Kotlin">

```kotlin
private fun getPostAndTodo(postId: String, todoId: String): GraphQLRequest<String> {
    val document = ("query get(\$postId: ID!, \$todoId: ID!) { "
            + "getPost(id: \$postId) { "
                + "id "
                + "title "
                + "rating "
            + "} "
            + "getTodo(id: \$todoId) { "
                + "id "
                + "name "
            + "} "
        + "}")

    return SimpleGraphQLRequest(
            document,
            mapOf("postId" to postId, "todoId" to todoId),
            String::class.java,
            GsonVariablesSerializer())
}
```
</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
const getTodo = 'getTodo';
const getPost = 'getPost';
const graphQLDocument = '''
  query GetPostAndTodo(\$todoId: ID!, \$postId: ID!) {
    $getTodo(id: \$todoId) {
      id
      name
    }
    $getPost(id: \$postId) {
      id
      title
      rating
    }
  }

''';
final multiOperationRequest = GraphQLRequest<String>(
  document: graphQLDocument,
  variables: <String, String>{'todoId': someTodoId, 'postId': somePostId},
);
```
Notice here that `modelType` and `decodePath` are omitted. When these decoding variables are omitted, the plugin simply returns the result as a raw `String` from the response.

Once you have the response data in a `String`, you can parse it using `json.decode()` and pass the resulting `Map` to the model's `fromJson()` method to create an instance of the model.

```dart
// Do not forget to add this to imports for json.decode
import 'dart:convert';

...

Future<void> queryMultiOperationRequest(
  GraphQLRequest<String> operation,
) async {
  final response =
      await Amplify.API.query(request: multiOperationRequest).response;
  if (response.data != null) {
    final jsonData =
        (json.decode(response.data) as Map).cast<String, Object?>();
    final post =
        Post.fromJson((jsonData[getPost] as Map).cast<String, Object?>);
    final todo =
        Todo.fromJson((jsonData[getTodo] as Map).cast<String, Object?>);
  }
}
```


</InlineFilter>

<Callout>

Combining multiple GraphQL requests on the client-side is different than server-side transaction support. To run multiple transactions as a batch operation refer to the [Batch Put Custom Resolver](/cli/graphql/examples-and-solutions/#batch-put-custom-resolver) example.

</Callout>

## Adding Headers to Outgoing Requests

By default, the API plugin includes appropriate authorization headers on your outgoing requests. However, you may have an advanced use case where you wish to send additional request headers to AppSync.

<InlineFilter filters={["ios"]}>

To include custom headers in your outgoing requests, add an `URLRequestInterceptor` to the `AWSAPIPlugin`. Also specify the name of one of the APIs configured in your **amplifyconfiguration.json** file.

```swift
struct CustomInterceptor: URLRequestInterceptor {
    func intercept(_ request: URLRequest) throws -> URLRequest {
        var request = request
        request.setValue("headerValue", forHTTPHeaderField: "headerKey")
        return request
    }
}
let apiPlugin = try AWSAPIPlugin()
try Amplify.addPlugin(apiPlugin)
try Amplify.configure()
try apiPlugin.add(interceptor: CustomInterceptor(), for: "yourApiName")
```


</InlineFilter>


<InlineFilter filters={["android"]}>

To specify your own headers, use the `configureClient()` configuration option on the `AWSApiPlugin`'s builder. Specify the name of one of the configured APIs in your **amplifyconfiguration.json**. Apply customizations to the underlying OkHttp instance by providing a lambda expression as below.

<BlockSwitcher>
<Block name="Java">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName", okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName") { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName") { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="RxJava">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient("yourApiName", okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
RxAmplify.addPlugin(plugin);
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

The simplest option for GraphQL requests is to use the `headers` property of a `GraphQLRequest`.

```dart
Future<void> queryWithCustomHeaders() async {
  final operation = Amplify.API.query<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      headers: {'customHeader': 'someValue'},
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}
```

Another option is to use the `baseHttpClient` property of the API plugin which can customize headers or otherwise alter HTTP functionality for all HTTP calls.

```dart
// First create a custom HTTP client implementation to extend HTTP functionality.
class MyHttpRequestInterceptor extends AWSBaseHttpClient {
  @override
  Future<AWSBaseHttpRequest> transformRequest(
    AWSBaseHttpRequest request,
  ) async {
    request.headers.putIfAbsent('customHeader', () => 'someValue');
    return request;
  }
}

// Then you can pass an instance of this client to `baseHttpClient` when you configure Amplify.
await Amplify.addPlugins([
  AmplifyAPI(baseHttpClient: MyHttpRequestInterceptor()),
]);
```


</InlineFilter>

</InlineFilter>