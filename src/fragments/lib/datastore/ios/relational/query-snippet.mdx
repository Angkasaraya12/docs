Models with one-to-many connections are lazy-loaded when accessing the connected property, so accessing a relation is as simple as:

<BlockSwitcher>

<Block name="Async/Await">

```swift
do {
    let postResult = try await Amplify.DataStore.save(postWithComments)
    print("Post with Comment saved! \(postResult)")
    // call fetch to lazy load the postResult before accessing it's result
    try await postResult.comments?.fetch()
    if let comments = postResult.comments {
        for comment in comments {
            print(comment.content)
        }
    } else {
        print("Post not found")
    }
} catch let error as DataStoreError {
        print("Failed with error \(error)")
    } catch {
        print("Unexpected error \(error)")
    }
```

</Block>

<Block name="Combine">

```swift
let sink = Amplify.DataStore.query(Post.self, byIdentifier: "123")
    .compactMap { $0?.comments }
    .flatMap { $0.loadAsPublisher() }
    .sink {
        if case let .failure(error) = $0 {
            print("Error retrieving post \(error.localizedDescription)")
        }
    }
    receiveValue: {
        for comment in $0 {
            print(comment.content)
        }
    }
```

</Block>

</BlockSwitcher>

The connected properties are of type `List<M>`, where `M` is the model type, and that type is a custom [Swift Collection](https://developer.apple.com/documentation/swift/collection), which means that you can `filter`, `map`, etc:

```swift
let excitedComments = postWithComments
    .comments?
    .compactMap { $0.content }
    .filter { $0.contains("Wow!") }
```
