The Storage and GraphQL API categories can be used together to associate a file, such as an image or video, with a particular record. For example, you might create a `Person` model with a profile picture, or a `Post` model with an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file within the model itself to create an association.

To get started, run the following in an existing Amplify project:

```bash
npm i @aws-amplify/ui-react  #For Authenticator component
amplify add auth             #Select default configuration
amplify add storage          #Select S3 with read/write access
amplify add api              #Select Cognito User Pool for authorization type
```

When prompted, use the following schema:

```graphql
type Song @model @auth(rules: [{ allow: public}]) {
  id: ID!
  name: String!
  covertArtKey: String #Set as optional to allow adding file after initial create
}
```

Save the schema and run `amplify push` to deploy the changes.

To use files and attachments you need authorization credentials for reading and writing to Amazon S3, which `amplify add auth` configures in the default setting along with a Cognito User Pool.

The Storage and API categories govern data access based on their own authorization patterns. Adding an `@auth` directive to the API schema does not guard against access in the Storage category. When you run `amplify add storage`, the CLI will configure appropriate IAM policies on the bucket using a Cognito Identity Pool Role. You will then have the option of adding CRUD (Create/Update, Read and Delete) based permissions as well, so that Authenticated and Guest users will be granted limited permissions within these levels. For more on configuring Storage authorization levels, see the [Storage documentation](https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/).

For more on configuring API authorization (separate from Storage authorization), see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/authz/q/platform/js/).

<Callout>

For the complete working example, including required imports, obtaining the file from the user, and React component state management, see the [Complete Example](#complete-example) below.

<Callout>

## Create a record with an associated file

First upload the file to Storage, then run the following mutation with the GraphQL API to create a record and associate the file with the record.

<Callout>

Note: In the case of adding a file to an existing record (such as when a user uploads a profile picture to an existing profile), first create the record and exclude the optional file reference, then follow the steps under [Adding / updating an associated file](#adding--updating-an-associated-file) below to add / update the file reference.

</Callout>

<BlockSwitcher>
<Block name="TypeScript">

```ts
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});


const songDetails: CreateSongInput = {
  name: `My first song`,
  coverArtKey: result?.key,
};

const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
  query: mutations.createSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
// TODO: add after PM feedback
```

</Block>
</BlockSwitcher>

## Add or update a file for an associated record

To associate a file with a record, update the record with the key returned by the Storage upload. The following example calls the helper function to upload the file using Storage, updates the record with the file's key, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});

const songDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: key,
};

const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>

## Query a record and retrieve the associated file

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Query the record to get the file key:
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });
const _song = response.data?.getSong;

// Check that the record has an associated image:
if (!_song?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(_song?.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
// TODO:
```

</Block>
</BlockSwitcher>

## Delete and remove files associated with API records.
There are three primary deletion workflows when working with Storage files and GraphQL API:

1. Remove the file association, continue to persist both file and record.
2. Keep the record, remove the record association, and delete the file.
2. Delete both file and record.

### Remove the file association, continue to persist both file and record.

The following example removes the file from the record, but does not delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const songDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: null,
};

const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>

### Keep the record, remove the record association, and delete the file.

The following example removes the file from the record, then delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: null,
};

// Remove associated file from record
const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

// Delete the file from S3:
const deletedImage = await Storage.remove(_song?.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>

### Delete both file and record.

When deleting a record, we may also want to delete the associated file:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Deletes current song. If song has an image, deletes image from Storage:
async function deleteCurrentSong() {
  if (!currentSong) return;
  const _song = await getSong();
  // Save the file key for deleting the file after the record is deleted:
  const currentSongImageKey = _song?.coverArtKey;
  const songDetails: DeleteSongInput = {
    id: currentSong.id,
  };
  try {
    const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
      query: mutations.deleteSong,
      variables: { input: songDetails },
    });
    setCurrentSong(null);
    if (!currentSongImageKey) return;
    try {
      const deletedImage = await Storage.remove(currentSongImageKey);
      clearLocalState();
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  } catch (error) {
    console.error("Error deleting song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>

## Complete example

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { GraphQLQuery } from "@aws-amplify/api";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import {
  CreateSongInput,
  CreateSongMutation,
  DeleteSongInput,
  DeleteSongMutation,
  GetSongQuery,
  ListSongsQuery,
  UpdateSongInput,
  UpdateSongMutation,
} from "./API";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";

function App() {
  const [currentSong, setCurrentSong] = useState<any>();
  const [currentImageUrl, setCurrentImageUrl] = useState<
    string | null | undefined
  >("");

  async function createSong() {
    const songDetails: CreateSongInput = {
      name: 'My first song',
    };

    try {
      const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
        query: mutations.createSong,
        variables: { input: songDetails },
      });
      setCurrentSong(response?.data?.createSong);
    } catch (error) {
      console.error("Error creating song: ", error);
    }
  }

  async function uploadImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const result = await Storage.put(file.name, file, {
        contentType: "image/png", // contentType is optional
      });

      return result?.key;
    } catch (error) {
      console.error("Error uploading image: ", error);
    }
  }

  // Upload image, add to song, retrieve signed URL and retrieve the image.
  // Also updates image if one already exists.
  async function addImageToSong(e: React.ChangeEvent<HTMLInputElement>) {
    if (!currentSong) return;

    // Upload the image to S3:
    const key = await uploadImage(e);

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      coverArtKey: key,
    };

    // Add the image to the current song:
    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      setCurrentSong(updatedSong?.data?.updateSong);

      // Retrieve the image for the current song:
      await getImageForCurrentSong();
    } catch (error) {
      console.error("Error adding image to song: ", error);
    }
  }

  async function getSong() {
    if (!currentSong) return;

    try {
      const oneSong = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      return oneSong.data?.getSong;
    } catch (error) {
      console.error("Error retrieving song: ", error);
    }
  }

  async function getImageForCurrentSong() {
    // Query the record to get the file key:
    const _song = await getSong();
    // Check that the record has an associated image:
    if (!_song?.coverArtKey) return;
    // Retrieve the signed URL:
    const signedURL = await Storage.get(_song?.coverArtKey);
    setCurrentImageUrl(signedURL);
  }

  // Removes the image from the song, but does not delete from Storage:
  async function removeImageFromSong() {
    if (!currentSong) return;

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      coverArtKey: null,
    };

    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      
      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error removing image from song: ", error);
    }
  }

  // Removes image from song, then deletes image from storage:
  async function deleteImageForCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    if (!_song?.coverArtKey) return;

    await removeImageFromSong();

    try {
      // Delete the file from S3:
      const deletedImage = await Storage.remove(_song?.coverArtKey);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Deletes current song. If song has an image, deletes image from Storage:
  async function deleteCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    // Save the file key for deleting the file after the record is deleted:
    const currentSongImageKey = _song?.coverArtKey;

    const songDetails: DeleteSongInput = {
      id: currentSong.id,
    };

    try {
      const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
        query: mutations.deleteSong,
        variables: { input: songDetails },
      });

      setCurrentSong(null);

      if (!currentSongImageKey) return;

      try {
        const deletedImage = await Storage.remove(currentSongImageKey);
        clearLocalState();
      } catch (error) {
        console.error("Error deleting image: ", error);
      }
    } catch (error) {
      console.error("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          <button onClick={createSong}>Create Song</button>
          <label>
            Add / Update current song image:
            <input
              id="name"
              type="file"
              onChange={addImageToSong}
              disabled={!currentSong}
            />
          </label>
          <button
            onClick={getImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Get image for current song
          </button>
          <button
            onClick={removeImageFromSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song (does not delete image)
          </button>
          <button
            onClick={deleteImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song, then delete image
          </button>
          <button onClick={deleteCurrentSong} disabled={!currentSong}>
            Delete current song
          </button>
          <button onClick={signOut}>Sign out</button>
          {currentImageUrl && (
            <img src={currentImageUrl} alt="Image for current song"></img>
          )}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>