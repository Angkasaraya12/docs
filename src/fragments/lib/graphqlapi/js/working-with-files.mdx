Many times you might want to associate a file, such as an images or video, with a particular record. For example, you might create a `Person` model with a profile picture, or a `Post` model with an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file within the model itself to create an association.

To get started, run the following in an existing Amplify project:

```bash
amplify add auth        #Select default configuration
amplify add storage     #Select S3 with read/write access
amplify add api         #Select Cognito User Pool for authorization type
```

When prompted, use the following schema:

```graphql
type Song @model {
  id: ID!
  name: String!
  covertArtKey: String
}
```

Save the schema and run `amplify push` to deploy the changes.

To use files and attachments you need authorization credentials for reading and writing to Amazon S3, which `amplify add auth` configures in the default setting along with a Cognito User Pool. For more details on Storage / API authorization, see the [Configuring Authorization](#configuring-authorization) section below.

For the complete working example, including required imports and React component state management, see the [Complete Example](#complete-example) below.

## Creating a record with a GraphQL API:

Running the following mutation will create a record with the GraphQL API. The corresponding file will be associated with this record.

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function createSong() {
  const songDetails: CreateSongInput = {
    name: `My first song`,
  };

  try {
    const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
      query: mutations.createSong,
      variables: { input: songDetails },
    });
    setCurrentSong(response?.data?.createSong);
  } catch (error) {
    console.error("Error creating song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Query the record with the GraphQL API:

The following helper function will be used to retrieve the record from the GraphQL API in the examples below:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function getSong() {
  if (!currentSong) return;

  try {
    const oneSong = await API.graphql<GraphQLQuery<GetSongQuery>>({
      query: queries.getSong,
      variables: { id: currentSong.id },
    });

    return oneSong.data?.getSong;
  } catch (error) {
    console.error("Error retrieving song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Uploading the file to S3:

Create a helper function that will handle uploading the file to S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function uploadImage(e: React.ChangeEvent<HTMLInputElement>) {
  if (!e.target.files) return;

  const file = e.target.files[0];

  try {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  } catch (error) {
    console.error("Error uploading image: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Adding / updating an associated file:

To associate a file with a record, update the record with the key returned by the Storage upload. The following example calls the helper function to upload the file using Storage, updates the record with the file's key, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function addImageToSong(e: React.ChangeEvent<HTMLInputElement>) {
  if (!currentSong) return;

  // Upload the image to S3:
  const key = await uploadImage(e);

  const songDetails: UpdateSongInput = {
    id: currentSong.id,
    coverArtKey: key,
  };

  // Add the image to the current song:
  try {
    const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
      query: mutations.updateSong,
      variables: { input: songDetails },
    });
    setCurrentSong(updatedSong?.data?.updateSong);

    // Retrieve the image for the current song:
    await getImageForCurrentSong();
  } catch (error) {
    console.error("Error adding image to song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Retrieving the associated file from the record:

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function getImageForCurrentSong() {
  // Query the record to get the file key:
  const _song = await getSong();
  // Check that the record has an associated image:
  if (!_song?.coverArtKey) return;
  // Retrieve the signed URL:
  const signedURL = await Storage.get(_song?.coverArtKey);
  setCurrentImageUrl(signedURL);
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Deleting and removing associated files:

Once a file has been associated with a record, the file can be removed from the record, deleted from S3, or both.

### Removing the file from the record:

The following example removes the file from the record, but does not delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function removeImageFromSong() {
  if (!currentSong) return;

  const songDetails: UpdateSongInput = {
    id: currentSong.id,
    coverArtKey: null,
  };

  try {
    const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
      query: mutations.updateSong,
      variables: { input: songDetails },
    });

    // If successful, the response here will be `null`:
    setCurrentSong(updatedSong?.data?.updateSong);
    setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
  } catch (error) {
    console.error("Error removing image from song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

### Removing and deleting the file:

The following example removes the file from the record, then delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function deleteImageForCurrentSong() {
  if (!currentSong) return;

  const _song = await getSong();

  if (!_song?.coverArtKey) return;

  await removeImageFromSong();

  try {
    // Delete the file from S3:
    const deletedImage = await Storage.remove(_song?.coverArtKey);
  } catch (error) {
    console.error("Error deleting image: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

### Deleting the record and associated file:

When deleting a record, we may also want to delete the associated file:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Deletes current song. If song has an image, deletes image from Storage:
async function deleteCurrentSong() {
  if (!currentSong) return;

  const _song = await getSong();

  // Save the file key for deleting the file after the record is deleted:
  const currentSongImageKey = _song?.coverArtKey;

  const songDetails: DeleteSongInput = {
    id: currentSong.id,
  };

  try {
    const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
      query: mutations.deleteSong,
      variables: { input: songDetails },
    });

    setCurrentSong(null);

    if (!currentSongImageKey) return;

    try {
      const deletedImage = await Storage.remove(currentSongImageKey);
      clearLocalState();
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  } catch (error) {
    console.error("Error deleting song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Configuring Authorization:
When you run `amplify add storage`, the CLI will configure appropriate IAM policies on the bucket using a Cognito Identity Pool Role. You will have the option of adding CRUD (Create/Update, Read and Delete) based permissions as well, so that Authenticated and Guest users will be granted limited permissions within these levels. For more on configuring Storage authorization levels, see the [Storage documentation](https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/).

For more on configuring API authorization, see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/authz/q/platform/js/).

## Complete Example:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { GraphQLQuery } from "@aws-amplify/api";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import {
  CreateSongInput,
  CreateSongMutation,
  DeleteSongInput,
  DeleteSongMutation,
  GetSongQuery,
  ListSongsQuery,
  UpdateSongInput,
  UpdateSongMutation,
} from "./API";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";

function App() {
  const [currentSong, setCurrentSong] = useState<any>();
  const [currentImageUrl, setCurrentImageUrl] = useState<
    string | null | undefined
  >("");

  async function createSong() {
    const songDetails: CreateSongInput = {
      name: 'My first song',
    };

    try {
      const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
        query: mutations.createSong,
        variables: { input: songDetails },
      });
      setCurrentSong(response?.data?.createSong);
    } catch (error) {
      console.error("Error creating song: ", error);
    }
  }

  async function uploadImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const result = await Storage.put(file.name, file, {
        contentType: "image/png", // contentType is optional
      });

      return result?.key;
    } catch (error) {
      console.error("Error uploading image: ", error);
    }
  }

  // Upload image, add to song, retrieve signed URL and retrieve the image.
  // Also updates image if one already exists.
  async function addImageToSong(e: any) {
    if (!currentSong) return;

    // Upload the image to S3:
    const key = await uploadImage(e);

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      coverArtKey: key,
    };

    // Add the image to the current song:
    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      setCurrentSong(updatedSong?.data?.updateSong);

      // Retrieve the image for the current song:
      await getImageForCurrentSong();
    } catch (error) {
      console.error("Error adding image to song: ", error);
    }
  }

  async function getSong() {
    if (!currentSong) return;

    try {
      const oneSong = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      return oneSong.data?.getSong;
    } catch (error) {
      console.error("Error retrieving song: ", error);
    }
  }

async function getImageForCurrentSong() {
  // Query the record to get the file key:
  const _song = await getSong();
  // Check that the record has an associated image:
  if (!_song?.coverArtKey) return;
  // Retrieve the signed URL:
  const signedURL = await Storage.get(_song?.coverArtKey);
  setCurrentImageUrl(signedURL);
}

  // Removes the image from the song, but does not delete from Storage:
  async function removeImageFromSong() {
    if (!currentSong) return;

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      coverArtKey: null,
    };

    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      
      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error removing image from song: ", error);
    }
  }

  // Removes image from song, then deletes image from storage:
  async function deleteImageForCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    if (!_song?.coverArtKey) return;

    await removeImageFromSong();

    try {
      // Delete the file from S3:
      const deletedImage = await Storage.remove(_song?.coverArtKey);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Deletes current song. If song has an image, deletes image from Storage:
  async function deleteCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    // Save the file key for deleting the file after the record is deleted:
    const currentSongImageKey = _song?.coverArtKey;

    const songDetails: DeleteSongInput = {
      id: currentSong.id,
    };

    try {
      const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
        query: mutations.deleteSong,
        variables: { input: songDetails },
      });

      setCurrentSong(null);

      if (!currentSongImageKey) return;

      try {
        const deletedImage = await Storage.remove(currentSongImageKey);
        clearLocalState();
      } catch (error) {
        console.error("Error deleting image: ", error);
      }
    } catch (error) {
      console.error("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          <button onClick={createSong}>Create Song</button>
          <label>
            Add / Update current song image:
            <input
              id="name"
              type="file"
              onChange={addImageToSong}
              disabled={!currentSong}
            />
          </label>
          <button
            onClick={getImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Get image for current song
          </button>
          <button
            onClick={removeImageFromSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song (does not delete image)
          </button>
          <button
            onClick={deleteImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song, then delete image
          </button>
          <button onClick={deleteCurrentSong} disabled={!currentSong}>
            Delete current song
          </button>
          <button onClick={signOut}>Sign out</button>
          {currentImageUrl && (
            <img src={currentImageUrl} alt="Image for current song"></img>
          )}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
``` 