The Storage and GraphQL API categories can be used together to associate a file, such as an image or video, with a particular record. For example, you might create a `User` model with a profile picture, or a `Post` model with an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file within the model itself to create an association.

To get started, run the following in an existing Amplify project:

```bash
npm i @aws-amplify/ui-react  #For Authenticator component
amplify add auth             #Select default configuration
amplify add storage          #Select S3 with read/write access
amplify add api              #Select Cognito User Pool for authorization type
```

When prompted, use the following schema:

```graphql
type Song @model @auth(rules: [{ allow: public}]) {
  id: ID!
  name: String!
  covertArtKey: String #Set as optional to allow adding file after initial create
}
```

Save the schema and run `amplify push` to deploy the changes.

To use files and attachments you need authorization credentials for reading and writing to Amazon S3, which `amplify add auth` configures in the default setting along with a Cognito User Pool.

<Callout>

The Storage and API categories govern data access based on their own authorization patterns. Adding an `@auth` directive to the API schema does not guard against access in the Storage category. When you run `amplify add storage`, the CLI will configure appropriate IAM policies on the bucket using a Cognito Identity Pool role. You will then have the option of adding CRUD (Create, Update, Read and Delete) based permissions as well, so that Authenticated and Guest users will be granted limited permissions within these levels. For more on configuring Storage authorization levels, see the [Storage documentation](https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/).

</Callout>

For more on configuring API authorization (separate from Storage authorization), see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/authz/q/platform/js/).

<Callout>

For the complete working example, including required imports, obtaining the file from the user, and React component state management, see the [Complete Example](#complete-example) below.

</Callout>

## Create a record with an associated file

First upload the file to Storage, then run the following mutation with the GraphQL API to create a record and associate the file with the record.

<Callout>

Note: In the case of adding a file to an existing record (such as when a user uploads a profile picture to an existing profile), first create the record and exclude the optional file reference, then follow the steps under [Add or update a file for an associated record](#add-or-update-a-file-for-an-associated-record) below.

</Callout>

<BlockSwitcher>
<Block name="TypeScript">

```ts
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});


const songDetails: CreateSongInput = {
  name: `My first song`,
  coverArtKey: result?.key,
};

const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
  query: mutations.createSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});


const songDetails = {
  name: `My first song`,
  coverArtKey: result?.key,
};

const response = await API.graphql({
  query: mutations.createSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

## Add or update a file for an associated record

To associate a file with a record, update the record with the key returned by the Storage upload. The following example calls the helper function to upload the file using Storage, updates the record with the file's key, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});

const songDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: key,
};

const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});

const songDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: key,
};

const updatedSong = await API.graphql({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

## Query a record and retrieve the associated file

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Query the record to get the file key:
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });
const _song = response.data?.getSong;

// Check that the record has an associated image:
if (!_song?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(_song?.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
// Query the record to get the file key:
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });
const _song = response.data?.getSong;

// Check that the record has an associated image:
if (!_song?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(_song?.coverArtKey);
```

</Block>
</BlockSwitcher>

## Delete and remove files associated with API records
There are three common deletion workflows when working with Storage files and the GraphQL API:

1. Remove the file association, continue to persist both file and record.
2. Remove the record association and delete the file.
2. Delete both file and record.

### Remove the file association, continue to persist both file and record

The following example removes the file association from the record, but does not delete the file from S3, nor the record from the database.

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: _song.id,
  coverArtKey: null,
};

const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

const songDetails = {
  id: _song.id,
  coverArtKey: null,
};

const updatedSong = await API.graphql({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

### Remove the record association and delete the file

The following example removes the file from the record, then deletes the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
  query: queries.getSong,
  variables: { id: currentSong.id },
});

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: _song.id,
  coverArtKey: null, // Set the file association to `null`
};

// Remove associated file from record
const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

// Delete the file from S3:
await Storage.remove(_song?.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
  query: queries.getSong,
  variables: { id: currentSong.id },
});

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: _song.id,
  coverArtKey: null, // Set the file association to `null`
};

// Remove associated file from record
const updatedSong = await API.graphql({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

// Delete the file from S3:
await Storage.remove(_song?.coverArtKey);
```

</Block>
</BlockSwitcher>

### Delete both file and record

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

await Storage.remove(_song?.coverArtKey);

const songDetails: DeleteSongInput = {
  id: _song.id,
};

const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
  query: mutations.deleteSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const _song = response?.data?.getSong;

if (!_song?.coverArtKey) return;

await Storage.remove(_song?.coverArtKey);

const songDetails = {
  id: _song.id,
};

const deletedSong = await API.graphql({
  query: mutations.deleteSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

## Complete example

<BlockSwitcher>
<Block name="TypeScript">

```ts
// TODO: add after PM feedback
``` 

</Block>
<Block name="JavaScript">

```js
// TODO: add after PM feedback
```

</Block>
</BlockSwitcher>