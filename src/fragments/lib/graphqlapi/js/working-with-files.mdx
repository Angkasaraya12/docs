## Working with Files and Attachments:

Many times you might want to create logical objects that have more complex data, such as images or videos, as part of their structure. For example, you might create a Person model with a profile picture, or a Post model that has an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file / attachment within the model to associate the record with the file.

To get started, run the following in an existing Amplify project:

```bash
amplify add auth        #Select default configuration
amplify add storage     #Select S3 with read/write access
amplify add api         #Select Cognito User Pool for authorization type
```

When prompted, use the following schema:

```graphql
type Song @model {
  id: ID!
  name: String!
  covertArtKey: String
}
```

For now, we'll stick with public access for both the API and Storage categories. For adding authorization to both, see the end of this tutorial.

Save the schema and run `amplify push` to deploy changes.

To use files and attachments you need authorization credentials for reading and writing to Amazon S3, which `amplify add auth` configures in the default setting along with a Cognito user pool.

// corresponding file in an S3 bucket.
For the complete working example, including required imports and React component state management, see the [Complete Example](#complete-example) at the end of this tutorial.

## Creating a Record with GraphQL API:

Running the following mutation will create a record with the GraphQL API. This record will be what we will use to associate the corresponding record:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function createSong() {
  const songDetails: CreateSongInput = {
    name: `Song ${Date.now()}`,
  };

  try {
    const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
      query: mutations.createSong,
      variables: { input: songDetails },
    });
    setCurrentSong(response?.data?.createSong);
  } catch (error) {
    console.log("Error creating song: ", error);
  }
}
``` 

## Query the record with the GraphQL API:

The following helper function will be used to retrieve the record from the GraphQL API.

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function getSong() {
  if (!currentSong) return;

  try {
    const oneSong = await API.graphql<GraphQLQuery<GetSongQuery>>({
      query: queries.getSong,
      variables: { id: currentSong.id },
    });

    return oneSong.data?.getSong;
  } catch (error) {
    console.log("Error retrieving song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Uploading the file to S3:

Create a helper function that will handle uploading the file to S3. This function will be called when the user selects a file to upload:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function uploadImage(e: React.ChangeEvent<HTMLInputElement>) {
  if (!e.target.files) return;

  const file = e.target.files[0];

  try {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  } catch (error) {
    console.log("Error uploading image: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Adding / updating an associated file:

To associate a file / attachment with a record, update the record with the key returned by the Storage upload. The following example calls the helper function to upload the file using Storage, updates the record with the file's key, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function addImageToSong(e: React.ChangeEvent<HTMLInputElement>) {
  if (!currentSong) return;

  // Upload the image to S3:
  const key = await uploadImage(e);

  const songDetails: UpdateSongInput = {
    id: currentSong.id,
    fileKey: key,
  };

  // Add the image to the current song:
  try {
    const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
      query: mutations.updateSong,
      variables: { input: songDetails },
    });
    setCurrentSong(updatedSong?.data?.updateSong);

    // Retrieve the image for the current song:
    await getImageForCurrentSong();
  } catch (error) {
    console.log("Error adding image to song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Retrieving the associated file from the record:

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function getImageForCurrentSong() {
  // Query the record to get the file key:
  const _song = await getSong();
  // Check that the record has an associated image:
  if (!_song?.fileKey) return;
  const signedURL = await Storage.get(_song?.fileKey);
  setCurrentImageUrl(signedURL);
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Deleting and removing associated files:

Once a file has been associated with a record, the file can be removed from the record, deleted from S3, or both.

### Removing the file from the record:

Removes the file from the record, but does not delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function removeImageFromSong() {
  if (!currentSong) return;

  const songDetails: UpdateSongInput = {
    id: currentSong.id,
    fileKey: null,
  };

  try {
    const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
      query: mutations.updateSong,
      variables: { input: songDetails },
    });

    // If successful, the response here will be `null`:
    setCurrentSong(updatedSong?.data?.updateSong);
    setCurrentImageUrl(updatedSong?.data?.updateSong?.fileKey);
  } catch (error) {
    console.log("Error removing image from song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

### Removing then deleting the file:

Remove the file from the record, then delete the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
async function deleteImageForCurrentSong() {
  if (!currentSong) return;

  const _song = await getSong();

  if (!_song?.fileKey) return;

  await removeImageFromSong();

  try {
    const deletedImage = await Storage.remove(_song?.fileKey);
    console.log("Image deleted: ", deletedImage);
  } catch (error) {
    console.log("Error deleting image: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

### Deleting the record and associated file:

When deleting a record, we may also want to delete the associated file:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Deletes current song. If song has an image, deletes image from Storage:
async function deleteCurrentSong() {
  if (!currentSong) return;

  const _song = await getSong();

  // Save the file key for deleting the file after the record is deleted:
  const currentSongImageKey = _song?.fileKey;

  const songDetails: DeleteSongInput = {
    id: currentSong.id,
  };

  try {
    const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
      query: mutations.deleteSong,
      variables: { input: songDetails },
    });

    console.log("Song deleted: ", deletedSong?.data?.deleteSong);
    setCurrentSong(null);

    if (!currentSongImageKey) return;

    try {
      const deletedImage = await Storage.remove(currentSongImageKey);
      console.log("Image deleted: ", deletedImage);
      clearLocalState();
    } catch (error) {
      console.log("Error deleting image: ", error);
    }
  } catch (error) {
    console.log("Error deleting song: ", error);
  }
}
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

## Complete Example:

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { GraphQLQuery } from "@aws-amplify/api";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import {
  CreateSongInput,
  CreateSongMutation,
  DeleteSongInput,
  DeleteSongMutation,
  GetSongQuery,
  ListSongsQuery,
  UpdateSongInput,
  UpdateSongMutation,
} from "./API";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";

function App() {
  // For the docs, we're only performing CRUD on one song at a time:
  const [currentSong, setCurrentSong] = useState<any>();
  // For displaying the image for the current song:
  const [currentImageUrl, setCurrentImageUrl] = useState<
    string | null | undefined
  >("");

  async function createSong() {
    const songDetails: CreateSongInput = {
      name: `Song ${Date.now()}`,
    };

    try {
      const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
        query: mutations.createSong,
        variables: { input: songDetails },
      });
      setCurrentSong(response?.data?.createSong);
    } catch (error) {
      console.log("Error creating song: ", error);
    }
  }

  // Helper function, perhaps combine with `addImageToSong`?
  async function uploadImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Unique identifier added for testing purposes (i.e. using same image for multiple uploads)
      // Will remove for docs.
      const result = await Storage.put(`${file.name}-${Date.now()}`, file, {
        contentType: "image/png", // contentType is optional
      });

      return result?.key;
    } catch (error) {
      console.log("Error uploading image: ", error);
    }
  }

  // Upload image, add to song, retrieve presigned URL and retrieve the image.
  // Also updates image if one already exists.
  async function addImageToSong(e: any) {
    if (!currentSong) return;

    // Upload the image to S3:
    const key = await uploadImage(e);

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      fileKey: key,
    };

    // Add the image to the current song:
    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      setCurrentSong(updatedSong?.data?.updateSong);

      // Retrieve the image for the current song:
      await getImageForCurrentSong();
    } catch (error) {
      console.log("Error adding image to song: ", error);
    }
  }

  async function getSong() {
    if (!currentSong) return;

    try {
      const oneSong = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      return oneSong.data?.getSong;
    } catch (error) {
      console.log("Error retrieving song: ", error);
    }
  }

  // Retrieves the signed url and sets the current image url:
  async function getImageForCurrentSong() {
    const _song = await getSong();
    if (!_song?.fileKey) return;
    const signedURL = await Storage.get(_song?.fileKey);
    setCurrentImageUrl(signedURL);
  }

  // Removes the image from the song, but does NOT delete from storage:
  async function removeImageFromSong() {
    if (!currentSong) return;

    const songDetails: UpdateSongInput = {
      id: currentSong.id,
      fileKey: null,
    };

    try {
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });
      console.log("Image removed from song: ", updatedSong?.data?.updateSong);
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.fileKey);
    } catch (error) {
      console.log("Error removing image from song: ", error);
    }
  }

  // Removes image from song, then deletes image from storage:
  async function deleteImageForCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    if (!_song?.fileKey) return;

    await removeImageFromSong();

    try {
      const deletedImage = await Storage.remove(_song?.fileKey);
      console.log("Image deleted: ", deletedImage);
    } catch (error) {
      console.log("Error deleting image: ", error);
    }
  }

  // Deletes current song. If song has an image, deletes image from storage:
  async function deleteCurrentSong() {
    if (!currentSong) return;

    const _song = await getSong();

    // Save for deleting image after song is deleted:
    const currentSongImageKey = _song?.fileKey;

    const songDetails: DeleteSongInput = {
      id: currentSong.id,
    };

    try {
      const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
        query: mutations.deleteSong,
        variables: { input: songDetails },
      });

      console.log("Song deleted: ", deletedSong?.data?.deleteSong);
      setCurrentSong(null);

      if (!currentSongImageKey) return;

      try {
        const deletedImage = await Storage.remove(currentSongImageKey);
        console.log("Image deleted: ", deletedImage);
        clearLocalState();
      } catch (error) {
        console.log("Error deleting image: ", error);
      }
    } catch (error) {
      console.log("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  // NOTE: For test / sample cleanup purposes only (not for docs example)
  async function deleteAll() {
    //region: delete songs:
    const response = await API.graphql<GraphQLQuery<ListSongsQuery>>({
      query: queries.listSongs,
    });

    console.log("Songs to delete", response?.data?.listSongs?.items);

    await response?.data?.listSongs?.items.forEach(async (song) => {
      if (!song?.id) return;

      const todoDetails: DeleteSongInput = {
        id: song?.id,
      };

      const deletedTodo = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
        query: mutations.deleteSong,
        variables: { input: todoDetails },
      });

      console.log("Song deleted: ", deletedTodo);
    });
    //endregion

    // Delete all images:
    await Storage.list("", { pageSize: "ALL" })
      .then(({ results }) => {
        results.forEach(async (result) => {
          if (!result?.key) return;
          try {
            const deletedImage = await Storage.remove(result?.key);
            console.log("Image deleted:", deletedImage);
          } catch (error) {
            console.log("Error deleting image: ", error);
          }
        });
      })
      .catch((err) => console.log(err));

    //region verify all deletes were successful:
    const secondResponse = await API.graphql<GraphQLQuery<ListSongsQuery>>({
      query: queries.listSongs,
    });
    console.log(
      "Songs should be empty:",
      secondResponse?.data?.listSongs?.items
    );

    const storageResponse = await Storage.list("", { pageSize: "ALL" });
    console.log("Images should be empty:", storageResponse?.results);

    if (
      secondResponse?.data?.listSongs?.items?.length === 0 &&
      storageResponse?.results?.length === 0
    ) {
      console.log("All deletes successful!");
      clearLocalState();
    }
    //endregion
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}</h1>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          <button onClick={createSong}>Create Song</button>
          <label>
            Add / Update current song image:
            <input
              id="name"
              type="file"
              onChange={addImageToSong}
              disabled={!currentSong}
            />
          </label>
          <button
            onClick={getImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Get image for current song
          </button>
          <button
            onClick={removeImageFromSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song (does not delete image)
          </button>
          <button
            onClick={deleteImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song, then delete image
          </button>
          <button onClick={deleteCurrentSong} disabled={!currentSong}>
            Delete current song)
          </button>
          <button onClick={deleteAll}>Delete All</button>
          <button onClick={signOut}>Sign out</button>
          {currentImageUrl && (
            <img src={currentImageUrl} alt="Image for current song"></img>
          )}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>

<BlockSwitcher>
<Block name="TypeScript">

```ts

``` 

</Block>
<Block name="JavaScript">

```js

```

</Block>
</BlockSwitcher>